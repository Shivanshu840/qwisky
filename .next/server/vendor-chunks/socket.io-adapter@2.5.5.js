"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/socket.io-adapter@2.5.5";
exports.ids = ["vendor-chunks/socket.io-adapter@2.5.5"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/cluster-adapter.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/cluster-adapter.js ***!
  \***********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ClusterAdapterWithHeartbeat = exports.ClusterAdapter = exports.MessageType = void 0;\nconst in_memory_adapter_1 = __webpack_require__(/*! ./in-memory-adapter */ \"(rsc)/./node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/in-memory-adapter.js\");\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js\");\nconst crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\nconst debug = (0, debug_1.debug)(\"socket.io-adapter\");\nconst EMITTER_UID = \"emitter\";\nconst DEFAULT_TIMEOUT = 5000;\nfunction randomId() {\n    return (0, crypto_1.randomBytes)(8).toString(\"hex\");\n}\nvar MessageType;\n(function (MessageType) {\n    MessageType[MessageType[\"INITIAL_HEARTBEAT\"] = 1] = \"INITIAL_HEARTBEAT\";\n    MessageType[MessageType[\"HEARTBEAT\"] = 2] = \"HEARTBEAT\";\n    MessageType[MessageType[\"BROADCAST\"] = 3] = \"BROADCAST\";\n    MessageType[MessageType[\"SOCKETS_JOIN\"] = 4] = \"SOCKETS_JOIN\";\n    MessageType[MessageType[\"SOCKETS_LEAVE\"] = 5] = \"SOCKETS_LEAVE\";\n    MessageType[MessageType[\"DISCONNECT_SOCKETS\"] = 6] = \"DISCONNECT_SOCKETS\";\n    MessageType[MessageType[\"FETCH_SOCKETS\"] = 7] = \"FETCH_SOCKETS\";\n    MessageType[MessageType[\"FETCH_SOCKETS_RESPONSE\"] = 8] = \"FETCH_SOCKETS_RESPONSE\";\n    MessageType[MessageType[\"SERVER_SIDE_EMIT\"] = 9] = \"SERVER_SIDE_EMIT\";\n    MessageType[MessageType[\"SERVER_SIDE_EMIT_RESPONSE\"] = 10] = \"SERVER_SIDE_EMIT_RESPONSE\";\n    MessageType[MessageType[\"BROADCAST_CLIENT_COUNT\"] = 11] = \"BROADCAST_CLIENT_COUNT\";\n    MessageType[MessageType[\"BROADCAST_ACK\"] = 12] = \"BROADCAST_ACK\";\n    MessageType[MessageType[\"ADAPTER_CLOSE\"] = 13] = \"ADAPTER_CLOSE\";\n})(MessageType = exports.MessageType || (exports.MessageType = {}));\nfunction encodeOptions(opts) {\n    return {\n        rooms: [...opts.rooms],\n        except: [...opts.except],\n        flags: opts.flags,\n    };\n}\nfunction decodeOptions(opts) {\n    return {\n        rooms: new Set(opts.rooms),\n        except: new Set(opts.except),\n        flags: opts.flags,\n    };\n}\n/**\n * A cluster-ready adapter. Any extending class must:\n *\n * - implement {@link ClusterAdapter#doPublish} and {@link ClusterAdapter#doPublishResponse}\n * - call {@link ClusterAdapter#onMessage} and {@link ClusterAdapter#onResponse}\n */\nclass ClusterAdapter extends in_memory_adapter_1.Adapter {\n    constructor(nsp) {\n        super(nsp);\n        this.requests = new Map();\n        this.ackRequests = new Map();\n        this.uid = randomId();\n    }\n    /**\n     * Called when receiving a message from another member of the cluster.\n     *\n     * @param message\n     * @param offset\n     * @protected\n     */\n    onMessage(message, offset) {\n        if (message.uid === this.uid) {\n            return debug(\"[%s] ignore message from self\", this.uid);\n        }\n        debug(\"[%s] new event of type %d from %s\", this.uid, message.type, message.uid);\n        switch (message.type) {\n            case MessageType.BROADCAST: {\n                const withAck = message.data.requestId !== undefined;\n                if (withAck) {\n                    super.broadcastWithAck(message.data.packet, decodeOptions(message.data.opts), (clientCount) => {\n                        debug(\"[%s] waiting for %d client acknowledgements\", this.uid, clientCount);\n                        this.publishResponse(message.uid, {\n                            type: MessageType.BROADCAST_CLIENT_COUNT,\n                            data: {\n                                requestId: message.data.requestId,\n                                clientCount,\n                            },\n                        });\n                    }, (arg) => {\n                        debug(\"[%s] received acknowledgement with value %j\", this.uid, arg);\n                        this.publishResponse(message.uid, {\n                            type: MessageType.BROADCAST_ACK,\n                            data: {\n                                requestId: message.data.requestId,\n                                packet: arg,\n                            },\n                        });\n                    });\n                }\n                else {\n                    const packet = message.data.packet;\n                    const opts = decodeOptions(message.data.opts);\n                    this.addOffsetIfNecessary(packet, opts, offset);\n                    super.broadcast(packet, opts);\n                }\n                break;\n            }\n            case MessageType.SOCKETS_JOIN:\n                super.addSockets(decodeOptions(message.data.opts), message.data.rooms);\n                break;\n            case MessageType.SOCKETS_LEAVE:\n                super.delSockets(decodeOptions(message.data.opts), message.data.rooms);\n                break;\n            case MessageType.DISCONNECT_SOCKETS:\n                super.disconnectSockets(decodeOptions(message.data.opts), message.data.close);\n                break;\n            case MessageType.FETCH_SOCKETS: {\n                debug(\"[%s] calling fetchSockets with opts %j\", this.uid, message.data.opts);\n                super\n                    .fetchSockets(decodeOptions(message.data.opts))\n                    .then((localSockets) => {\n                    this.publishResponse(message.uid, {\n                        type: MessageType.FETCH_SOCKETS_RESPONSE,\n                        data: {\n                            requestId: message.data.requestId,\n                            sockets: localSockets.map((socket) => {\n                                // remove sessionStore from handshake, as it may contain circular references\n                                const _a = socket.handshake, { sessionStore } = _a, handshake = __rest(_a, [\"sessionStore\"]);\n                                return {\n                                    id: socket.id,\n                                    handshake,\n                                    rooms: [...socket.rooms],\n                                    data: socket.data,\n                                };\n                            }),\n                        },\n                    });\n                });\n                break;\n            }\n            case MessageType.SERVER_SIDE_EMIT: {\n                const packet = message.data.packet;\n                const withAck = message.data.requestId !== undefined;\n                if (!withAck) {\n                    this.nsp._onServerSideEmit(packet);\n                    return;\n                }\n                let called = false;\n                const callback = (arg) => {\n                    // only one argument is expected\n                    if (called) {\n                        return;\n                    }\n                    called = true;\n                    debug(\"[%s] calling acknowledgement with %j\", this.uid, arg);\n                    this.publishResponse(message.uid, {\n                        type: MessageType.SERVER_SIDE_EMIT_RESPONSE,\n                        data: {\n                            requestId: message.data.requestId,\n                            packet: arg,\n                        },\n                    });\n                };\n                this.nsp._onServerSideEmit([...packet, callback]);\n                break;\n            }\n            // @ts-ignore\n            case MessageType.BROADCAST_CLIENT_COUNT:\n            // @ts-ignore\n            case MessageType.BROADCAST_ACK:\n            // @ts-ignore\n            case MessageType.FETCH_SOCKETS_RESPONSE:\n            // @ts-ignore\n            case MessageType.SERVER_SIDE_EMIT_RESPONSE:\n                // extending classes may not make a distinction between a ClusterMessage and a ClusterResponse payload and may\n                // always call the onMessage() method\n                this.onResponse(message);\n                break;\n            default:\n                debug(\"[%s] unknown message type: %s\", this.uid, message.type);\n        }\n    }\n    /**\n     * Called when receiving a response from another member of the cluster.\n     *\n     * @param response\n     * @protected\n     */\n    onResponse(response) {\n        var _a, _b;\n        const requestId = response.data.requestId;\n        debug(\"[%s] received response %s to request %s\", this.uid, response.type, requestId);\n        switch (response.type) {\n            case MessageType.BROADCAST_CLIENT_COUNT: {\n                (_a = this.ackRequests\n                    .get(requestId)) === null || _a === void 0 ? void 0 : _a.clientCountCallback(response.data.clientCount);\n                break;\n            }\n            case MessageType.BROADCAST_ACK: {\n                (_b = this.ackRequests.get(requestId)) === null || _b === void 0 ? void 0 : _b.ack(response.data.packet);\n                break;\n            }\n            case MessageType.FETCH_SOCKETS_RESPONSE: {\n                const request = this.requests.get(requestId);\n                if (!request) {\n                    return;\n                }\n                request.current++;\n                response.data.sockets.forEach((socket) => request.responses.push(socket));\n                if (request.current === request.expected) {\n                    clearTimeout(request.timeout);\n                    request.resolve(request.responses);\n                    this.requests.delete(requestId);\n                }\n                break;\n            }\n            case MessageType.SERVER_SIDE_EMIT_RESPONSE: {\n                const request = this.requests.get(requestId);\n                if (!request) {\n                    return;\n                }\n                request.current++;\n                request.responses.push(response.data.packet);\n                if (request.current === request.expected) {\n                    clearTimeout(request.timeout);\n                    request.resolve(null, request.responses);\n                    this.requests.delete(requestId);\n                }\n                break;\n            }\n            default:\n                // @ts-ignore\n                debug(\"[%s] unknown response type: %s\", this.uid, response.type);\n        }\n    }\n    async broadcast(packet, opts) {\n        var _a;\n        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n        if (!onlyLocal) {\n            try {\n                const offset = await this.publishAndReturnOffset({\n                    type: MessageType.BROADCAST,\n                    data: {\n                        packet,\n                        opts: encodeOptions(opts),\n                    },\n                });\n                this.addOffsetIfNecessary(packet, opts, offset);\n            }\n            catch (e) {\n                return debug(\"[%s] error while broadcasting message: %s\", this.uid, e.message);\n            }\n        }\n        super.broadcast(packet, opts);\n    }\n    /**\n     * Adds an offset at the end of the data array in order to allow the client to receive any missed packets when it\n     * reconnects after a temporary disconnection.\n     *\n     * @param packet\n     * @param opts\n     * @param offset\n     * @private\n     */\n    addOffsetIfNecessary(packet, opts, offset) {\n        var _a;\n        if (!this.nsp.server.opts.connectionStateRecovery) {\n            return;\n        }\n        const isEventPacket = packet.type === 2;\n        // packets with acknowledgement are not stored because the acknowledgement function cannot be serialized and\n        // restored on another server upon reconnection\n        const withoutAcknowledgement = packet.id === undefined;\n        const notVolatile = ((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.volatile) === undefined;\n        if (isEventPacket && withoutAcknowledgement && notVolatile) {\n            packet.data.push(offset);\n        }\n    }\n    broadcastWithAck(packet, opts, clientCountCallback, ack) {\n        var _a;\n        const onlyLocal = (_a = opts === null || opts === void 0 ? void 0 : opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n        if (!onlyLocal) {\n            const requestId = randomId();\n            this.ackRequests.set(requestId, {\n                clientCountCallback,\n                ack,\n            });\n            this.publish({\n                type: MessageType.BROADCAST,\n                data: {\n                    packet,\n                    requestId,\n                    opts: encodeOptions(opts),\n                },\n            });\n            // we have no way to know at this level whether the server has received an acknowledgement from each client, so we\n            // will simply clean up the ackRequests map after the given delay\n            setTimeout(() => {\n                this.ackRequests.delete(requestId);\n            }, opts.flags.timeout);\n        }\n        super.broadcastWithAck(packet, opts, clientCountCallback, ack);\n    }\n    async addSockets(opts, rooms) {\n        var _a;\n        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n        if (!onlyLocal) {\n            try {\n                await this.publishAndReturnOffset({\n                    type: MessageType.SOCKETS_JOIN,\n                    data: {\n                        opts: encodeOptions(opts),\n                        rooms,\n                    },\n                });\n            }\n            catch (e) {\n                debug(\"[%s] error while publishing message: %s\", this.uid, e.message);\n            }\n        }\n        super.addSockets(opts, rooms);\n    }\n    async delSockets(opts, rooms) {\n        var _a;\n        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n        if (!onlyLocal) {\n            try {\n                await this.publishAndReturnOffset({\n                    type: MessageType.SOCKETS_LEAVE,\n                    data: {\n                        opts: encodeOptions(opts),\n                        rooms,\n                    },\n                });\n            }\n            catch (e) {\n                debug(\"[%s] error while publishing message: %s\", this.uid, e.message);\n            }\n        }\n        super.delSockets(opts, rooms);\n    }\n    async disconnectSockets(opts, close) {\n        var _a;\n        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;\n        if (!onlyLocal) {\n            try {\n                await this.publishAndReturnOffset({\n                    type: MessageType.DISCONNECT_SOCKETS,\n                    data: {\n                        opts: encodeOptions(opts),\n                        close,\n                    },\n                });\n            }\n            catch (e) {\n                debug(\"[%s] error while publishing message: %s\", this.uid, e.message);\n            }\n        }\n        super.disconnectSockets(opts, close);\n    }\n    async fetchSockets(opts) {\n        var _a;\n        const [localSockets, serverCount] = await Promise.all([\n            super.fetchSockets(opts),\n            this.serverCount(),\n        ]);\n        const expectedResponseCount = serverCount - 1;\n        if (((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local) || expectedResponseCount <= 0) {\n            return localSockets;\n        }\n        const requestId = randomId();\n        return new Promise((resolve, reject) => {\n            const timeout = setTimeout(() => {\n                const storedRequest = this.requests.get(requestId);\n                if (storedRequest) {\n                    reject(new Error(`timeout reached: only ${storedRequest.current} responses received out of ${storedRequest.expected}`));\n                    this.requests.delete(requestId);\n                }\n            }, opts.flags.timeout || DEFAULT_TIMEOUT);\n            const storedRequest = {\n                type: MessageType.FETCH_SOCKETS,\n                resolve,\n                timeout,\n                current: 0,\n                expected: expectedResponseCount,\n                responses: localSockets,\n            };\n            this.requests.set(requestId, storedRequest);\n            this.publish({\n                type: MessageType.FETCH_SOCKETS,\n                data: {\n                    opts: encodeOptions(opts),\n                    requestId,\n                },\n            });\n        });\n    }\n    async serverSideEmit(packet) {\n        const withAck = typeof packet[packet.length - 1] === \"function\";\n        if (!withAck) {\n            return this.publish({\n                type: MessageType.SERVER_SIDE_EMIT,\n                data: {\n                    packet,\n                },\n            });\n        }\n        const ack = packet.pop();\n        const expectedResponseCount = (await this.serverCount()) - 1;\n        debug('[%s] waiting for %d responses to \"serverSideEmit\" request', this.uid, expectedResponseCount);\n        if (expectedResponseCount <= 0) {\n            return ack(null, []);\n        }\n        const requestId = randomId();\n        const timeout = setTimeout(() => {\n            const storedRequest = this.requests.get(requestId);\n            if (storedRequest) {\n                ack(new Error(`timeout reached: only ${storedRequest.current} responses received out of ${storedRequest.expected}`), storedRequest.responses);\n                this.requests.delete(requestId);\n            }\n        }, DEFAULT_TIMEOUT);\n        const storedRequest = {\n            type: MessageType.SERVER_SIDE_EMIT,\n            resolve: ack,\n            timeout,\n            current: 0,\n            expected: expectedResponseCount,\n            responses: [],\n        };\n        this.requests.set(requestId, storedRequest);\n        this.publish({\n            type: MessageType.SERVER_SIDE_EMIT,\n            data: {\n                requestId,\n                packet,\n            },\n        });\n    }\n    publish(message) {\n        this.publishAndReturnOffset(message).catch((err) => {\n            debug(\"[%s] error while publishing message: %s\", this.uid, err);\n        });\n    }\n    publishAndReturnOffset(message) {\n        message.uid = this.uid;\n        message.nsp = this.nsp.name;\n        return this.doPublish(message);\n    }\n    publishResponse(requesterUid, response) {\n        response.uid = this.uid;\n        response.nsp = this.nsp.name;\n        this.doPublishResponse(requesterUid, response).catch((err) => {\n            debug(\"[%s] error while publishing response: %s\", this.uid, err);\n        });\n    }\n}\nexports.ClusterAdapter = ClusterAdapter;\nclass ClusterAdapterWithHeartbeat extends ClusterAdapter {\n    constructor(nsp, opts) {\n        super(nsp);\n        this.nodesMap = new Map(); // uid => timestamp of last message\n        this.customRequests = new Map();\n        this._opts = Object.assign({\n            heartbeatInterval: 5000,\n            heartbeatTimeout: 10000,\n        }, opts);\n        this.cleanupTimer = setInterval(() => {\n            const now = Date.now();\n            this.nodesMap.forEach((lastSeen, uid) => {\n                const nodeSeemsDown = now - lastSeen > this._opts.heartbeatTimeout;\n                if (nodeSeemsDown) {\n                    debug(\"[%s] node %s seems down\", this.uid, uid);\n                    this.removeNode(uid);\n                }\n            });\n        }, 1000);\n    }\n    init() {\n        this.publish({\n            type: MessageType.INITIAL_HEARTBEAT,\n        });\n    }\n    scheduleHeartbeat() {\n        if (this.heartbeatTimer) {\n            this.heartbeatTimer.refresh();\n        }\n        else {\n            this.heartbeatTimer = setTimeout(() => {\n                this.publish({\n                    type: MessageType.HEARTBEAT,\n                });\n            }, this._opts.heartbeatInterval);\n        }\n    }\n    close() {\n        this.publish({\n            type: MessageType.ADAPTER_CLOSE,\n        });\n        clearTimeout(this.heartbeatTimer);\n        if (this.cleanupTimer) {\n            clearInterval(this.cleanupTimer);\n        }\n    }\n    onMessage(message, offset) {\n        if (message.uid === this.uid) {\n            return debug(\"[%s] ignore message from self\", this.uid);\n        }\n        if (message.uid && message.uid !== EMITTER_UID) {\n            // we track the UID of each sender, in order to know how many servers there are in the cluster\n            this.nodesMap.set(message.uid, Date.now());\n        }\n        debug(\"[%s] new event of type %d from %s\", this.uid, message.type, message.uid);\n        switch (message.type) {\n            case MessageType.INITIAL_HEARTBEAT:\n                this.publish({\n                    type: MessageType.HEARTBEAT,\n                });\n                break;\n            case MessageType.HEARTBEAT:\n                // nothing to do\n                break;\n            case MessageType.ADAPTER_CLOSE:\n                this.removeNode(message.uid);\n                break;\n            default:\n                super.onMessage(message, offset);\n        }\n    }\n    serverCount() {\n        return Promise.resolve(1 + this.nodesMap.size);\n    }\n    publish(message) {\n        this.scheduleHeartbeat();\n        return super.publish(message);\n    }\n    async serverSideEmit(packet) {\n        const withAck = typeof packet[packet.length - 1] === \"function\";\n        if (!withAck) {\n            return this.publish({\n                type: MessageType.SERVER_SIDE_EMIT,\n                data: {\n                    packet,\n                },\n            });\n        }\n        const ack = packet.pop();\n        const expectedResponseCount = this.nodesMap.size;\n        debug('[%s] waiting for %d responses to \"serverSideEmit\" request', this.uid, expectedResponseCount);\n        if (expectedResponseCount <= 0) {\n            return ack(null, []);\n        }\n        const requestId = randomId();\n        const timeout = setTimeout(() => {\n            const storedRequest = this.customRequests.get(requestId);\n            if (storedRequest) {\n                ack(new Error(`timeout reached: missing ${storedRequest.missingUids.size} responses`), storedRequest.responses);\n                this.customRequests.delete(requestId);\n            }\n        }, DEFAULT_TIMEOUT);\n        const storedRequest = {\n            type: MessageType.SERVER_SIDE_EMIT,\n            resolve: ack,\n            timeout,\n            missingUids: new Set([...this.nodesMap.keys()]),\n            responses: [],\n        };\n        this.customRequests.set(requestId, storedRequest);\n        this.publish({\n            type: MessageType.SERVER_SIDE_EMIT,\n            data: {\n                requestId,\n                packet,\n            },\n        });\n    }\n    async fetchSockets(opts) {\n        var _a;\n        const [localSockets, serverCount] = await Promise.all([\n            super.fetchSockets({\n                rooms: opts.rooms,\n                except: opts.except,\n                flags: {\n                    local: true,\n                },\n            }),\n            this.serverCount(),\n        ]);\n        const expectedResponseCount = serverCount - 1;\n        if (((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local) || expectedResponseCount <= 0) {\n            return localSockets;\n        }\n        const requestId = randomId();\n        return new Promise((resolve, reject) => {\n            const timeout = setTimeout(() => {\n                const storedRequest = this.customRequests.get(requestId);\n                if (storedRequest) {\n                    reject(new Error(`timeout reached: missing ${storedRequest.missingUids.size} responses`));\n                    this.customRequests.delete(requestId);\n                }\n            }, opts.flags.timeout || DEFAULT_TIMEOUT);\n            const storedRequest = {\n                type: MessageType.FETCH_SOCKETS,\n                resolve,\n                timeout,\n                missingUids: new Set([...this.nodesMap.keys()]),\n                responses: localSockets,\n            };\n            this.customRequests.set(requestId, storedRequest);\n            this.publish({\n                type: MessageType.FETCH_SOCKETS,\n                data: {\n                    opts: encodeOptions(opts),\n                    requestId,\n                },\n            });\n        });\n    }\n    onResponse(response) {\n        const requestId = response.data.requestId;\n        debug(\"[%s] received response %s to request %s\", this.uid, response.type, requestId);\n        switch (response.type) {\n            case MessageType.FETCH_SOCKETS_RESPONSE: {\n                const request = this.customRequests.get(requestId);\n                if (!request) {\n                    return;\n                }\n                response.data.sockets.forEach((socket) => request.responses.push(socket));\n                request.missingUids.delete(response.uid);\n                if (request.missingUids.size === 0) {\n                    clearTimeout(request.timeout);\n                    request.resolve(request.responses);\n                    this.customRequests.delete(requestId);\n                }\n                break;\n            }\n            case MessageType.SERVER_SIDE_EMIT_RESPONSE: {\n                const request = this.customRequests.get(requestId);\n                if (!request) {\n                    return;\n                }\n                request.responses.push(response.data.packet);\n                request.missingUids.delete(response.uid);\n                if (request.missingUids.size === 0) {\n                    clearTimeout(request.timeout);\n                    request.resolve(null, request.responses);\n                    this.customRequests.delete(requestId);\n                }\n                break;\n            }\n            default:\n                super.onResponse(response);\n        }\n    }\n    removeNode(uid) {\n        this.customRequests.forEach((request, requestId) => {\n            request.missingUids.delete(uid);\n            if (request.missingUids.size === 0) {\n                clearTimeout(request.timeout);\n                if (request.type === MessageType.FETCH_SOCKETS) {\n                    request.resolve(request.responses);\n                }\n                else if (request.type === MessageType.SERVER_SIDE_EMIT) {\n                    request.resolve(null, request.responses);\n                }\n                this.customRequests.delete(requestId);\n            }\n        });\n        this.nodesMap.delete(uid);\n    }\n}\nexports.ClusterAdapterWithHeartbeat = ClusterAdapterWithHeartbeat;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vc29ja2V0LmlvLWFkYXB0ZXJAMi41LjUvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1hZGFwdGVyL2Rpc3QvY2x1c3Rlci1hZGFwdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUNBQW1DLEdBQUcsc0JBQXNCLEdBQUcsbUJBQW1CO0FBQ2xGLDRCQUE0QixtQkFBTyxDQUFDLHdJQUFxQjtBQUN6RCxnQkFBZ0IsbUJBQU8sQ0FBQyxxRkFBTztBQUMvQixpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QyxtQkFBbUIsS0FBSztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdDQUFnQyxLQUFLO0FBQ3JELFdBQVcsZ0NBQWdDLEtBQUs7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGVBQWU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsdUJBQXVCLDRCQUE0Qix1QkFBdUI7QUFDeEk7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCx1QkFBdUIsNEJBQTRCLHVCQUF1QjtBQUNqSTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxnQ0FBZ0M7QUFDMUY7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGdDQUFnQztBQUNqRztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL3NvY2tldC5pby1hZGFwdGVyQDIuNS41L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tYWRhcHRlci9kaXN0L2NsdXN0ZXItYWRhcHRlci5qcz85ZmEwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DbHVzdGVyQWRhcHRlcldpdGhIZWFydGJlYXQgPSBleHBvcnRzLkNsdXN0ZXJBZGFwdGVyID0gZXhwb3J0cy5NZXNzYWdlVHlwZSA9IHZvaWQgMDtcbmNvbnN0IGluX21lbW9yeV9hZGFwdGVyXzEgPSByZXF1aXJlKFwiLi9pbi1tZW1vcnktYWRhcHRlclwiKTtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCJjcnlwdG9cIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlYnVnKShcInNvY2tldC5pby1hZGFwdGVyXCIpO1xuY29uc3QgRU1JVFRFUl9VSUQgPSBcImVtaXR0ZXJcIjtcbmNvbnN0IERFRkFVTFRfVElNRU9VVCA9IDUwMDA7XG5mdW5jdGlvbiByYW5kb21JZCgpIHtcbiAgICByZXR1cm4gKDAsIGNyeXB0b18xLnJhbmRvbUJ5dGVzKSg4KS50b1N0cmluZyhcImhleFwiKTtcbn1cbnZhciBNZXNzYWdlVHlwZTtcbihmdW5jdGlvbiAoTWVzc2FnZVR5cGUpIHtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIklOSVRJQUxfSEVBUlRCRUFUXCJdID0gMV0gPSBcIklOSVRJQUxfSEVBUlRCRUFUXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJIRUFSVEJFQVRcIl0gPSAyXSA9IFwiSEVBUlRCRUFUXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJCUk9BRENBU1RcIl0gPSAzXSA9IFwiQlJPQURDQVNUXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJTT0NLRVRTX0pPSU5cIl0gPSA0XSA9IFwiU09DS0VUU19KT0lOXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJTT0NLRVRTX0xFQVZFXCJdID0gNV0gPSBcIlNPQ0tFVFNfTEVBVkVcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIkRJU0NPTk5FQ1RfU09DS0VUU1wiXSA9IDZdID0gXCJESVNDT05ORUNUX1NPQ0tFVFNcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIkZFVENIX1NPQ0tFVFNcIl0gPSA3XSA9IFwiRkVUQ0hfU09DS0VUU1wiO1xuICAgIE1lc3NhZ2VUeXBlW01lc3NhZ2VUeXBlW1wiRkVUQ0hfU09DS0VUU19SRVNQT05TRVwiXSA9IDhdID0gXCJGRVRDSF9TT0NLRVRTX1JFU1BPTlNFXCI7XG4gICAgTWVzc2FnZVR5cGVbTWVzc2FnZVR5cGVbXCJTRVJWRVJfU0lERV9FTUlUXCJdID0gOV0gPSBcIlNFUlZFUl9TSURFX0VNSVRcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIlNFUlZFUl9TSURFX0VNSVRfUkVTUE9OU0VcIl0gPSAxMF0gPSBcIlNFUlZFUl9TSURFX0VNSVRfUkVTUE9OU0VcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIkJST0FEQ0FTVF9DTElFTlRfQ09VTlRcIl0gPSAxMV0gPSBcIkJST0FEQ0FTVF9DTElFTlRfQ09VTlRcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIkJST0FEQ0FTVF9BQ0tcIl0gPSAxMl0gPSBcIkJST0FEQ0FTVF9BQ0tcIjtcbiAgICBNZXNzYWdlVHlwZVtNZXNzYWdlVHlwZVtcIkFEQVBURVJfQ0xPU0VcIl0gPSAxM10gPSBcIkFEQVBURVJfQ0xPU0VcIjtcbn0pKE1lc3NhZ2VUeXBlID0gZXhwb3J0cy5NZXNzYWdlVHlwZSB8fCAoZXhwb3J0cy5NZXNzYWdlVHlwZSA9IHt9KSk7XG5mdW5jdGlvbiBlbmNvZGVPcHRpb25zKG9wdHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByb29tczogWy4uLm9wdHMucm9vbXNdLFxuICAgICAgICBleGNlcHQ6IFsuLi5vcHRzLmV4Y2VwdF0sXG4gICAgICAgIGZsYWdzOiBvcHRzLmZsYWdzLFxuICAgIH07XG59XG5mdW5jdGlvbiBkZWNvZGVPcHRpb25zKG9wdHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByb29tczogbmV3IFNldChvcHRzLnJvb21zKSxcbiAgICAgICAgZXhjZXB0OiBuZXcgU2V0KG9wdHMuZXhjZXB0KSxcbiAgICAgICAgZmxhZ3M6IG9wdHMuZmxhZ3MsXG4gICAgfTtcbn1cbi8qKlxuICogQSBjbHVzdGVyLXJlYWR5IGFkYXB0ZXIuIEFueSBleHRlbmRpbmcgY2xhc3MgbXVzdDpcbiAqXG4gKiAtIGltcGxlbWVudCB7QGxpbmsgQ2x1c3RlckFkYXB0ZXIjZG9QdWJsaXNofSBhbmQge0BsaW5rIENsdXN0ZXJBZGFwdGVyI2RvUHVibGlzaFJlc3BvbnNlfVxuICogLSBjYWxsIHtAbGluayBDbHVzdGVyQWRhcHRlciNvbk1lc3NhZ2V9IGFuZCB7QGxpbmsgQ2x1c3RlckFkYXB0ZXIjb25SZXNwb25zZX1cbiAqL1xuY2xhc3MgQ2x1c3RlckFkYXB0ZXIgZXh0ZW5kcyBpbl9tZW1vcnlfYWRhcHRlcl8xLkFkYXB0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG5zcCkge1xuICAgICAgICBzdXBlcihuc3ApO1xuICAgICAgICB0aGlzLnJlcXVlc3RzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmFja1JlcXVlc3RzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnVpZCA9IHJhbmRvbUlkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHJlY2VpdmluZyBhIG1lc3NhZ2UgZnJvbSBhbm90aGVyIG1lbWJlciBvZiB0aGUgY2x1c3Rlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlXG4gICAgICogQHBhcmFtIG9mZnNldFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbk1lc3NhZ2UobWVzc2FnZSwgb2Zmc2V0KSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnVpZCA9PT0gdGhpcy51aWQpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWJ1ZyhcIlslc10gaWdub3JlIG1lc3NhZ2UgZnJvbSBzZWxmXCIsIHRoaXMudWlkKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyhcIlslc10gbmV3IGV2ZW50IG9mIHR5cGUgJWQgZnJvbSAlc1wiLCB0aGlzLnVpZCwgbWVzc2FnZS50eXBlLCBtZXNzYWdlLnVpZCk7XG4gICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkJST0FEQ0FTVDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpdGhBY2sgPSBtZXNzYWdlLmRhdGEucmVxdWVzdElkICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHdpdGhBY2spIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIuYnJvYWRjYXN0V2l0aEFjayhtZXNzYWdlLmRhdGEucGFja2V0LCBkZWNvZGVPcHRpb25zKG1lc3NhZ2UuZGF0YS5vcHRzKSwgKGNsaWVudENvdW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcIlslc10gd2FpdGluZyBmb3IgJWQgY2xpZW50IGFja25vd2xlZGdlbWVudHNcIiwgdGhpcy51aWQsIGNsaWVudENvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaFJlc3BvbnNlKG1lc3NhZ2UudWlkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuQlJPQURDQVNUX0NMSUVOVF9DT1VOVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogbWVzc2FnZS5kYXRhLnJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50Q291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LCAoYXJnKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcIlslc10gcmVjZWl2ZWQgYWNrbm93bGVkZ2VtZW50IHdpdGggdmFsdWUgJWpcIiwgdGhpcy51aWQsIGFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hSZXNwb25zZShtZXNzYWdlLnVpZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkJST0FEQ0FTVF9BQ0ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IG1lc3NhZ2UuZGF0YS5yZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhY2tldDogYXJnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWNrZXQgPSBtZXNzYWdlLmRhdGEucGFja2V0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRzID0gZGVjb2RlT3B0aW9ucyhtZXNzYWdlLmRhdGEub3B0cyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkT2Zmc2V0SWZOZWNlc3NhcnkocGFja2V0LCBvcHRzLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBzdXBlci5icm9hZGNhc3QocGFja2V0LCBvcHRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlNPQ0tFVFNfSk9JTjpcbiAgICAgICAgICAgICAgICBzdXBlci5hZGRTb2NrZXRzKGRlY29kZU9wdGlvbnMobWVzc2FnZS5kYXRhLm9wdHMpLCBtZXNzYWdlLmRhdGEucm9vbXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5TT0NLRVRTX0xFQVZFOlxuICAgICAgICAgICAgICAgIHN1cGVyLmRlbFNvY2tldHMoZGVjb2RlT3B0aW9ucyhtZXNzYWdlLmRhdGEub3B0cyksIG1lc3NhZ2UuZGF0YS5yb29tcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkRJU0NPTk5FQ1RfU09DS0VUUzpcbiAgICAgICAgICAgICAgICBzdXBlci5kaXNjb25uZWN0U29ja2V0cyhkZWNvZGVPcHRpb25zKG1lc3NhZ2UuZGF0YS5vcHRzKSwgbWVzc2FnZS5kYXRhLmNsb3NlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuRkVUQ0hfU09DS0VUUzoge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiWyVzXSBjYWxsaW5nIGZldGNoU29ja2V0cyB3aXRoIG9wdHMgJWpcIiwgdGhpcy51aWQsIG1lc3NhZ2UuZGF0YS5vcHRzKTtcbiAgICAgICAgICAgICAgICBzdXBlclxuICAgICAgICAgICAgICAgICAgICAuZmV0Y2hTb2NrZXRzKGRlY29kZU9wdGlvbnMobWVzc2FnZS5kYXRhLm9wdHMpKVxuICAgICAgICAgICAgICAgICAgICAudGhlbigobG9jYWxTb2NrZXRzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaFJlc3BvbnNlKG1lc3NhZ2UudWlkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5GRVRDSF9TT0NLRVRTX1JFU1BPTlNFLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogbWVzc2FnZS5kYXRhLnJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXRzOiBsb2NhbFNvY2tldHMubWFwKChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHNlc3Npb25TdG9yZSBmcm9tIGhhbmRzaGFrZSwgYXMgaXQgbWF5IGNvbnRhaW4gY2lyY3VsYXIgcmVmZXJlbmNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBfYSA9IHNvY2tldC5oYW5kc2hha2UsIHsgc2Vzc2lvblN0b3JlIH0gPSBfYSwgaGFuZHNoYWtlID0gX19yZXN0KF9hLCBbXCJzZXNzaW9uU3RvcmVcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHNvY2tldC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRzaGFrZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb21zOiBbLi4uc29ja2V0LnJvb21zXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHNvY2tldC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlNFUlZFUl9TSURFX0VNSVQ6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWNrZXQgPSBtZXNzYWdlLmRhdGEucGFja2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpdGhBY2sgPSBtZXNzYWdlLmRhdGEucmVxdWVzdElkICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKCF3aXRoQWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubnNwLl9vblNlcnZlclNpZGVFbWl0KHBhY2tldCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gKGFyZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IG9uZSBhcmd1bWVudCBpcyBleHBlY3RlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJbJXNdIGNhbGxpbmcgYWNrbm93bGVkZ2VtZW50IHdpdGggJWpcIiwgdGhpcy51aWQsIGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaFJlc3BvbnNlKG1lc3NhZ2UudWlkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5TRVJWRVJfU0lERV9FTUlUX1JFU1BPTlNFLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogbWVzc2FnZS5kYXRhLnJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWNrZXQ6IGFyZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5uc3AuX29uU2VydmVyU2lkZUVtaXQoWy4uLnBhY2tldCwgY2FsbGJhY2tdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuQlJPQURDQVNUX0NMSUVOVF9DT1VOVDpcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuQlJPQURDQVNUX0FDSzpcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuRkVUQ0hfU09DS0VUU19SRVNQT05TRTpcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuU0VSVkVSX1NJREVfRU1JVF9SRVNQT05TRTpcbiAgICAgICAgICAgICAgICAvLyBleHRlbmRpbmcgY2xhc3NlcyBtYXkgbm90IG1ha2UgYSBkaXN0aW5jdGlvbiBiZXR3ZWVuIGEgQ2x1c3Rlck1lc3NhZ2UgYW5kIGEgQ2x1c3RlclJlc3BvbnNlIHBheWxvYWQgYW5kIG1heVxuICAgICAgICAgICAgICAgIC8vIGFsd2F5cyBjYWxsIHRoZSBvbk1lc3NhZ2UoKSBtZXRob2RcbiAgICAgICAgICAgICAgICB0aGlzLm9uUmVzcG9uc2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGRlYnVnKFwiWyVzXSB1bmtub3duIG1lc3NhZ2UgdHlwZTogJXNcIiwgdGhpcy51aWQsIG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gcmVjZWl2aW5nIGEgcmVzcG9uc2UgZnJvbSBhbm90aGVyIG1lbWJlciBvZiB0aGUgY2x1c3Rlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZXNwb25zZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvblJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IHJlc3BvbnNlLmRhdGEucmVxdWVzdElkO1xuICAgICAgICBkZWJ1ZyhcIlslc10gcmVjZWl2ZWQgcmVzcG9uc2UgJXMgdG8gcmVxdWVzdCAlc1wiLCB0aGlzLnVpZCwgcmVzcG9uc2UudHlwZSwgcmVxdWVzdElkKTtcbiAgICAgICAgc3dpdGNoIChyZXNwb25zZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkJST0FEQ0FTVF9DTElFTlRfQ09VTlQ6IHtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmFja1JlcXVlc3RzXG4gICAgICAgICAgICAgICAgICAgIC5nZXQocmVxdWVzdElkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsaWVudENvdW50Q2FsbGJhY2socmVzcG9uc2UuZGF0YS5jbGllbnRDb3VudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkJST0FEQ0FTVF9BQ0s6IHtcbiAgICAgICAgICAgICAgICAoX2IgPSB0aGlzLmFja1JlcXVlc3RzLmdldChyZXF1ZXN0SWQpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWNrKHJlc3BvbnNlLmRhdGEucGFja2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuRkVUQ0hfU09DS0VUU19SRVNQT05TRToge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLnJlcXVlc3RzLmdldChyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcXVlc3QuY3VycmVudCsrO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEuc29ja2V0cy5mb3JFYWNoKChzb2NrZXQpID0+IHJlcXVlc3QucmVzcG9uc2VzLnB1c2goc29ja2V0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QuY3VycmVudCA9PT0gcmVxdWVzdC5leHBlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocmVxdWVzdC50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXNvbHZlKHJlcXVlc3QucmVzcG9uc2VzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0cy5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlNFUlZFUl9TSURFX0VNSVRfUkVTUE9OU0U6IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0cy5nZXQocmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXF1ZXN0LmN1cnJlbnQrKztcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlcy5wdXNoKHJlc3BvbnNlLmRhdGEucGFja2V0KTtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5jdXJyZW50ID09PSByZXF1ZXN0LmV4cGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChyZXF1ZXN0LnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc29sdmUobnVsbCwgcmVxdWVzdC5yZXNwb25zZXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGRlYnVnKFwiWyVzXSB1bmtub3duIHJlc3BvbnNlIHR5cGU6ICVzXCIsIHRoaXMudWlkLCByZXNwb25zZS50eXBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBicm9hZGNhc3QocGFja2V0LCBvcHRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgb25seUxvY2FsID0gKF9hID0gb3B0cy5mbGFncykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsO1xuICAgICAgICBpZiAoIW9ubHlMb2NhbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBhd2FpdCB0aGlzLnB1Ymxpc2hBbmRSZXR1cm5PZmZzZXQoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5CUk9BRENBU1QsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhY2tldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdHM6IGVuY29kZU9wdGlvbnMob3B0cyksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRPZmZzZXRJZk5lY2Vzc2FyeShwYWNrZXQsIG9wdHMsIG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWJ1ZyhcIlslc10gZXJyb3Igd2hpbGUgYnJvYWRjYXN0aW5nIG1lc3NhZ2U6ICVzXCIsIHRoaXMudWlkLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmJyb2FkY2FzdChwYWNrZXQsIG9wdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIG9mZnNldCBhdCB0aGUgZW5kIG9mIHRoZSBkYXRhIGFycmF5IGluIG9yZGVyIHRvIGFsbG93IHRoZSBjbGllbnQgdG8gcmVjZWl2ZSBhbnkgbWlzc2VkIHBhY2tldHMgd2hlbiBpdFxuICAgICAqIHJlY29ubmVjdHMgYWZ0ZXIgYSB0ZW1wb3JhcnkgZGlzY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYWNrZXRcbiAgICAgKiBAcGFyYW0gb3B0c1xuICAgICAqIEBwYXJhbSBvZmZzZXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFkZE9mZnNldElmTmVjZXNzYXJ5KHBhY2tldCwgb3B0cywgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLm5zcC5zZXJ2ZXIub3B0cy5jb25uZWN0aW9uU3RhdGVSZWNvdmVyeSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzRXZlbnRQYWNrZXQgPSBwYWNrZXQudHlwZSA9PT0gMjtcbiAgICAgICAgLy8gcGFja2V0cyB3aXRoIGFja25vd2xlZGdlbWVudCBhcmUgbm90IHN0b3JlZCBiZWNhdXNlIHRoZSBhY2tub3dsZWRnZW1lbnQgZnVuY3Rpb24gY2Fubm90IGJlIHNlcmlhbGl6ZWQgYW5kXG4gICAgICAgIC8vIHJlc3RvcmVkIG9uIGFub3RoZXIgc2VydmVyIHVwb24gcmVjb25uZWN0aW9uXG4gICAgICAgIGNvbnN0IHdpdGhvdXRBY2tub3dsZWRnZW1lbnQgPSBwYWNrZXQuaWQgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgbm90Vm9sYXRpbGUgPSAoKF9hID0gb3B0cy5mbGFncykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZvbGF0aWxlKSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoaXNFdmVudFBhY2tldCAmJiB3aXRob3V0QWNrbm93bGVkZ2VtZW50ICYmIG5vdFZvbGF0aWxlKSB7XG4gICAgICAgICAgICBwYWNrZXQuZGF0YS5wdXNoKG9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYnJvYWRjYXN0V2l0aEFjayhwYWNrZXQsIG9wdHMsIGNsaWVudENvdW50Q2FsbGJhY2ssIGFjaykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG9ubHlMb2NhbCA9IChfYSA9IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5mbGFncykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsO1xuICAgICAgICBpZiAoIW9ubHlMb2NhbCkge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdElkID0gcmFuZG9tSWQoKTtcbiAgICAgICAgICAgIHRoaXMuYWNrUmVxdWVzdHMuc2V0KHJlcXVlc3RJZCwge1xuICAgICAgICAgICAgICAgIGNsaWVudENvdW50Q2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgYWNrLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkJST0FEQ0FTVCxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHBhY2tldCxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICAgICAgICBvcHRzOiBlbmNvZGVPcHRpb25zKG9wdHMpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHdlIGhhdmUgbm8gd2F5IHRvIGtub3cgYXQgdGhpcyBsZXZlbCB3aGV0aGVyIHRoZSBzZXJ2ZXIgaGFzIHJlY2VpdmVkIGFuIGFja25vd2xlZGdlbWVudCBmcm9tIGVhY2ggY2xpZW50LCBzbyB3ZVxuICAgICAgICAgICAgLy8gd2lsbCBzaW1wbHkgY2xlYW4gdXAgdGhlIGFja1JlcXVlc3RzIG1hcCBhZnRlciB0aGUgZ2l2ZW4gZGVsYXlcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWNrUmVxdWVzdHMuZGVsZXRlKHJlcXVlc3RJZCk7XG4gICAgICAgICAgICB9LCBvcHRzLmZsYWdzLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmJyb2FkY2FzdFdpdGhBY2socGFja2V0LCBvcHRzLCBjbGllbnRDb3VudENhbGxiYWNrLCBhY2spO1xuICAgIH1cbiAgICBhc3luYyBhZGRTb2NrZXRzKG9wdHMsIHJvb21zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgb25seUxvY2FsID0gKF9hID0gb3B0cy5mbGFncykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsO1xuICAgICAgICBpZiAoIW9ubHlMb2NhbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnB1Ymxpc2hBbmRSZXR1cm5PZmZzZXQoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5TT0NLRVRTX0pPSU4sXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdHM6IGVuY29kZU9wdGlvbnMob3B0cyksXG4gICAgICAgICAgICAgICAgICAgICAgICByb29tcyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJbJXNdIGVycm9yIHdoaWxlIHB1Ymxpc2hpbmcgbWVzc2FnZTogJXNcIiwgdGhpcy51aWQsIGUubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuYWRkU29ja2V0cyhvcHRzLCByb29tcyk7XG4gICAgfVxuICAgIGFzeW5jIGRlbFNvY2tldHMob3B0cywgcm9vbXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBvbmx5TG9jYWwgPSAoX2EgPSBvcHRzLmZsYWdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9jYWw7XG4gICAgICAgIGlmICghb25seUxvY2FsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHVibGlzaEFuZFJldHVybk9mZnNldCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlNPQ0tFVFNfTEVBVkUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdHM6IGVuY29kZU9wdGlvbnMob3B0cyksXG4gICAgICAgICAgICAgICAgICAgICAgICByb29tcyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJbJXNdIGVycm9yIHdoaWxlIHB1Ymxpc2hpbmcgbWVzc2FnZTogJXNcIiwgdGhpcy51aWQsIGUubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuZGVsU29ja2V0cyhvcHRzLCByb29tcyk7XG4gICAgfVxuICAgIGFzeW5jIGRpc2Nvbm5lY3RTb2NrZXRzKG9wdHMsIGNsb3NlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgb25seUxvY2FsID0gKF9hID0gb3B0cy5mbGFncykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvY2FsO1xuICAgICAgICBpZiAoIW9ubHlMb2NhbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnB1Ymxpc2hBbmRSZXR1cm5PZmZzZXQoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5ESVNDT05ORUNUX1NPQ0tFVFMsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdHM6IGVuY29kZU9wdGlvbnMob3B0cyksXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJbJXNdIGVycm9yIHdoaWxlIHB1Ymxpc2hpbmcgbWVzc2FnZTogJXNcIiwgdGhpcy51aWQsIGUubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuZGlzY29ubmVjdFNvY2tldHMob3B0cywgY2xvc2UpO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaFNvY2tldHMob3B0cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IFtsb2NhbFNvY2tldHMsIHNlcnZlckNvdW50XSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHN1cGVyLmZldGNoU29ja2V0cyhvcHRzKSxcbiAgICAgICAgICAgIHRoaXMuc2VydmVyQ291bnQoKSxcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkUmVzcG9uc2VDb3VudCA9IHNlcnZlckNvdW50IC0gMTtcbiAgICAgICAgaWYgKCgoX2EgPSBvcHRzLmZsYWdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9jYWwpIHx8IGV4cGVjdGVkUmVzcG9uc2VDb3VudCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxTb2NrZXRzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IHJhbmRvbUlkKCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RvcmVkUmVxdWVzdCA9IHRoaXMucmVxdWVzdHMuZ2V0KHJlcXVlc3RJZCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JlZFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgdGltZW91dCByZWFjaGVkOiBvbmx5ICR7c3RvcmVkUmVxdWVzdC5jdXJyZW50fSByZXNwb25zZXMgcmVjZWl2ZWQgb3V0IG9mICR7c3RvcmVkUmVxdWVzdC5leHBlY3RlZH1gKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdHMuZGVsZXRlKHJlcXVlc3RJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgb3B0cy5mbGFncy50aW1lb3V0IHx8IERFRkFVTFRfVElNRU9VVCk7XG4gICAgICAgICAgICBjb25zdCBzdG9yZWRSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkZFVENIX1NPQ0tFVFMsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICB0aW1lb3V0LFxuICAgICAgICAgICAgICAgIGN1cnJlbnQ6IDAsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkUmVzcG9uc2VDb3VudCxcbiAgICAgICAgICAgICAgICByZXNwb25zZXM6IGxvY2FsU29ja2V0cyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RzLnNldChyZXF1ZXN0SWQsIHN0b3JlZFJlcXVlc3QpO1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5GRVRDSF9TT0NLRVRTLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgb3B0czogZW5jb2RlT3B0aW9ucyhvcHRzKSxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHNlcnZlclNpZGVFbWl0KHBhY2tldCkge1xuICAgICAgICBjb25zdCB3aXRoQWNrID0gdHlwZW9mIHBhY2tldFtwYWNrZXQubGVuZ3RoIC0gMV0gPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgaWYgKCF3aXRoQWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdWJsaXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5TRVJWRVJfU0lERV9FTUlULFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgcGFja2V0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY2sgPSBwYWNrZXQucG9wKCk7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkUmVzcG9uc2VDb3VudCA9IChhd2FpdCB0aGlzLnNlcnZlckNvdW50KCkpIC0gMTtcbiAgICAgICAgZGVidWcoJ1slc10gd2FpdGluZyBmb3IgJWQgcmVzcG9uc2VzIHRvIFwic2VydmVyU2lkZUVtaXRcIiByZXF1ZXN0JywgdGhpcy51aWQsIGV4cGVjdGVkUmVzcG9uc2VDb3VudCk7XG4gICAgICAgIGlmIChleHBlY3RlZFJlc3BvbnNlQ291bnQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGFjayhudWxsLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gcmFuZG9tSWQoKTtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkUmVxdWVzdCA9IHRoaXMucmVxdWVzdHMuZ2V0KHJlcXVlc3RJZCk7XG4gICAgICAgICAgICBpZiAoc3RvcmVkUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIGFjayhuZXcgRXJyb3IoYHRpbWVvdXQgcmVhY2hlZDogb25seSAke3N0b3JlZFJlcXVlc3QuY3VycmVudH0gcmVzcG9uc2VzIHJlY2VpdmVkIG91dCBvZiAke3N0b3JlZFJlcXVlc3QuZXhwZWN0ZWR9YCksIHN0b3JlZFJlcXVlc3QucmVzcG9uc2VzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBERUZBVUxUX1RJTUVPVVQpO1xuICAgICAgICBjb25zdCBzdG9yZWRSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuU0VSVkVSX1NJREVfRU1JVCxcbiAgICAgICAgICAgIHJlc29sdmU6IGFjayxcbiAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICBjdXJyZW50OiAwLFxuICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkUmVzcG9uc2VDb3VudCxcbiAgICAgICAgICAgIHJlc3BvbnNlczogW10sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVxdWVzdHMuc2V0KHJlcXVlc3RJZCwgc3RvcmVkUmVxdWVzdCk7XG4gICAgICAgIHRoaXMucHVibGlzaCh7XG4gICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5TRVJWRVJfU0lERV9FTUlULFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICBwYWNrZXQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcHVibGlzaChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMucHVibGlzaEFuZFJldHVybk9mZnNldChtZXNzYWdlKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyhcIlslc10gZXJyb3Igd2hpbGUgcHVibGlzaGluZyBtZXNzYWdlOiAlc1wiLCB0aGlzLnVpZCwgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHB1Ymxpc2hBbmRSZXR1cm5PZmZzZXQobWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlLnVpZCA9IHRoaXMudWlkO1xuICAgICAgICBtZXNzYWdlLm5zcCA9IHRoaXMubnNwLm5hbWU7XG4gICAgICAgIHJldHVybiB0aGlzLmRvUHVibGlzaChtZXNzYWdlKTtcbiAgICB9XG4gICAgcHVibGlzaFJlc3BvbnNlKHJlcXVlc3RlclVpZCwgcmVzcG9uc2UpIHtcbiAgICAgICAgcmVzcG9uc2UudWlkID0gdGhpcy51aWQ7XG4gICAgICAgIHJlc3BvbnNlLm5zcCA9IHRoaXMubnNwLm5hbWU7XG4gICAgICAgIHRoaXMuZG9QdWJsaXNoUmVzcG9uc2UocmVxdWVzdGVyVWlkLCByZXNwb25zZSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgZGVidWcoXCJbJXNdIGVycm9yIHdoaWxlIHB1Ymxpc2hpbmcgcmVzcG9uc2U6ICVzXCIsIHRoaXMudWlkLCBlcnIpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkNsdXN0ZXJBZGFwdGVyID0gQ2x1c3RlckFkYXB0ZXI7XG5jbGFzcyBDbHVzdGVyQWRhcHRlcldpdGhIZWFydGJlYXQgZXh0ZW5kcyBDbHVzdGVyQWRhcHRlciB7XG4gICAgY29uc3RydWN0b3IobnNwLCBvcHRzKSB7XG4gICAgICAgIHN1cGVyKG5zcCk7XG4gICAgICAgIHRoaXMubm9kZXNNYXAgPSBuZXcgTWFwKCk7IC8vIHVpZCA9PiB0aW1lc3RhbXAgb2YgbGFzdCBtZXNzYWdlXG4gICAgICAgIHRoaXMuY3VzdG9tUmVxdWVzdHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX29wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGhlYXJ0YmVhdEludGVydmFsOiA1MDAwLFxuICAgICAgICAgICAgaGVhcnRiZWF0VGltZW91dDogMTAwMDAsXG4gICAgICAgIH0sIG9wdHMpO1xuICAgICAgICB0aGlzLmNsZWFudXBUaW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB0aGlzLm5vZGVzTWFwLmZvckVhY2goKGxhc3RTZWVuLCB1aWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlU2VlbXNEb3duID0gbm93IC0gbGFzdFNlZW4gPiB0aGlzLl9vcHRzLmhlYXJ0YmVhdFRpbWVvdXQ7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVTZWVtc0Rvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJbJXNdIG5vZGUgJXMgc2VlbXMgZG93blwiLCB0aGlzLnVpZCwgdWlkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVOb2RlKHVpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIDEwMDApO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICB0aGlzLnB1Ymxpc2goe1xuICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuSU5JVElBTF9IRUFSVEJFQVQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzY2hlZHVsZUhlYXJ0YmVhdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVhcnRiZWF0VGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIucmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkhFQVJUQkVBVCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHRoaXMuX29wdHMuaGVhcnRiZWF0SW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnB1Ymxpc2goe1xuICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuQURBUFRFUl9DTE9TRSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmhlYXJ0YmVhdFRpbWVyKTtcbiAgICAgICAgaWYgKHRoaXMuY2xlYW51cFRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuY2xlYW51cFRpbWVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbk1lc3NhZ2UobWVzc2FnZSwgb2Zmc2V0KSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnVpZCA9PT0gdGhpcy51aWQpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWJ1ZyhcIlslc10gaWdub3JlIG1lc3NhZ2UgZnJvbSBzZWxmXCIsIHRoaXMudWlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS51aWQgJiYgbWVzc2FnZS51aWQgIT09IEVNSVRURVJfVUlEKSB7XG4gICAgICAgICAgICAvLyB3ZSB0cmFjayB0aGUgVUlEIG9mIGVhY2ggc2VuZGVyLCBpbiBvcmRlciB0byBrbm93IGhvdyBtYW55IHNlcnZlcnMgdGhlcmUgYXJlIGluIHRoZSBjbHVzdGVyXG4gICAgICAgICAgICB0aGlzLm5vZGVzTWFwLnNldChtZXNzYWdlLnVpZCwgRGF0ZS5ub3coKSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoXCJbJXNdIG5ldyBldmVudCBvZiB0eXBlICVkIGZyb20gJXNcIiwgdGhpcy51aWQsIG1lc3NhZ2UudHlwZSwgbWVzc2FnZS51aWQpO1xuICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5JTklUSUFMX0hFQVJUQkVBVDpcbiAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5IRUFSVEJFQVQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkhFQVJUQkVBVDpcbiAgICAgICAgICAgICAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkFEQVBURVJfQ0xPU0U6XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVOb2RlKG1lc3NhZ2UudWlkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgc3VwZXIub25NZXNzYWdlKG1lc3NhZ2UsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VydmVyQ291bnQoKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoMSArIHRoaXMubm9kZXNNYXAuc2l6ZSk7XG4gICAgfVxuICAgIHB1Ymxpc2gobWVzc2FnZSkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlSGVhcnRiZWF0KCk7XG4gICAgICAgIHJldHVybiBzdXBlci5wdWJsaXNoKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBhc3luYyBzZXJ2ZXJTaWRlRW1pdChwYWNrZXQpIHtcbiAgICAgICAgY29uc3Qgd2l0aEFjayA9IHR5cGVvZiBwYWNrZXRbcGFja2V0Lmxlbmd0aCAtIDFdID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgIGlmICghd2l0aEFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVibGlzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuU0VSVkVSX1NJREVfRU1JVCxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHBhY2tldCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWNrID0gcGFja2V0LnBvcCgpO1xuICAgICAgICBjb25zdCBleHBlY3RlZFJlc3BvbnNlQ291bnQgPSB0aGlzLm5vZGVzTWFwLnNpemU7XG4gICAgICAgIGRlYnVnKCdbJXNdIHdhaXRpbmcgZm9yICVkIHJlc3BvbnNlcyB0byBcInNlcnZlclNpZGVFbWl0XCIgcmVxdWVzdCcsIHRoaXMudWlkLCBleHBlY3RlZFJlc3BvbnNlQ291bnQpO1xuICAgICAgICBpZiAoZXhwZWN0ZWRSZXNwb25zZUNvdW50IDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBhY2sobnVsbCwgW10pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IHJhbmRvbUlkKCk7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZFJlcXVlc3QgPSB0aGlzLmN1c3RvbVJlcXVlc3RzLmdldChyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgaWYgKHN0b3JlZFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICBhY2sobmV3IEVycm9yKGB0aW1lb3V0IHJlYWNoZWQ6IG1pc3NpbmcgJHtzdG9yZWRSZXF1ZXN0Lm1pc3NpbmdVaWRzLnNpemV9IHJlc3BvbnNlc2ApLCBzdG9yZWRSZXF1ZXN0LnJlc3BvbnNlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXN0b21SZXF1ZXN0cy5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgREVGQVVMVF9USU1FT1VUKTtcbiAgICAgICAgY29uc3Qgc3RvcmVkUmVxdWVzdCA9IHtcbiAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlNFUlZFUl9TSURFX0VNSVQsXG4gICAgICAgICAgICByZXNvbHZlOiBhY2ssXG4gICAgICAgICAgICB0aW1lb3V0LFxuICAgICAgICAgICAgbWlzc2luZ1VpZHM6IG5ldyBTZXQoWy4uLnRoaXMubm9kZXNNYXAua2V5cygpXSksXG4gICAgICAgICAgICByZXNwb25zZXM6IFtdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmN1c3RvbVJlcXVlc3RzLnNldChyZXF1ZXN0SWQsIHN0b3JlZFJlcXVlc3QpO1xuICAgICAgICB0aGlzLnB1Ymxpc2goe1xuICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuU0VSVkVSX1NJREVfRU1JVCxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgcGFja2V0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoU29ja2V0cyhvcHRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgW2xvY2FsU29ja2V0cywgc2VydmVyQ291bnRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgc3VwZXIuZmV0Y2hTb2NrZXRzKHtcbiAgICAgICAgICAgICAgICByb29tczogb3B0cy5yb29tcyxcbiAgICAgICAgICAgICAgICBleGNlcHQ6IG9wdHMuZXhjZXB0LFxuICAgICAgICAgICAgICAgIGZsYWdzOiB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRoaXMuc2VydmVyQ291bnQoKSxcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkUmVzcG9uc2VDb3VudCA9IHNlcnZlckNvdW50IC0gMTtcbiAgICAgICAgaWYgKCgoX2EgPSBvcHRzLmZsYWdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9jYWwpIHx8IGV4cGVjdGVkUmVzcG9uc2VDb3VudCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxTb2NrZXRzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IHJhbmRvbUlkKCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RvcmVkUmVxdWVzdCA9IHRoaXMuY3VzdG9tUmVxdWVzdHMuZ2V0KHJlcXVlc3RJZCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JlZFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgdGltZW91dCByZWFjaGVkOiBtaXNzaW5nICR7c3RvcmVkUmVxdWVzdC5taXNzaW5nVWlkcy5zaXplfSByZXNwb25zZXNgKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VzdG9tUmVxdWVzdHMuZGVsZXRlKHJlcXVlc3RJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgb3B0cy5mbGFncy50aW1lb3V0IHx8IERFRkFVTFRfVElNRU9VVCk7XG4gICAgICAgICAgICBjb25zdCBzdG9yZWRSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkZFVENIX1NPQ0tFVFMsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICB0aW1lb3V0LFxuICAgICAgICAgICAgICAgIG1pc3NpbmdVaWRzOiBuZXcgU2V0KFsuLi50aGlzLm5vZGVzTWFwLmtleXMoKV0pLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlczogbG9jYWxTb2NrZXRzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tUmVxdWVzdHMuc2V0KHJlcXVlc3RJZCwgc3RvcmVkUmVxdWVzdCk7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkZFVENIX1NPQ0tFVFMsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBvcHRzOiBlbmNvZGVPcHRpb25zKG9wdHMpLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgb25SZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSByZXNwb25zZS5kYXRhLnJlcXVlc3RJZDtcbiAgICAgICAgZGVidWcoXCJbJXNdIHJlY2VpdmVkIHJlc3BvbnNlICVzIHRvIHJlcXVlc3QgJXNcIiwgdGhpcy51aWQsIHJlc3BvbnNlLnR5cGUsIHJlcXVlc3RJZCk7XG4gICAgICAgIHN3aXRjaCAocmVzcG9uc2UudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5GRVRDSF9TT0NLRVRTX1JFU1BPTlNFOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuY3VzdG9tUmVxdWVzdHMuZ2V0KHJlcXVlc3RJZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuZGF0YS5zb2NrZXRzLmZvckVhY2goKHNvY2tldCkgPT4gcmVxdWVzdC5yZXNwb25zZXMucHVzaChzb2NrZXQpKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm1pc3NpbmdVaWRzLmRlbGV0ZShyZXNwb25zZS51aWQpO1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0Lm1pc3NpbmdVaWRzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHJlcXVlc3QudGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzb2x2ZShyZXF1ZXN0LnJlc3BvbnNlcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VzdG9tUmVxdWVzdHMuZGVsZXRlKHJlcXVlc3RJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5TRVJWRVJfU0lERV9FTUlUX1JFU1BPTlNFOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuY3VzdG9tUmVxdWVzdHMuZ2V0KHJlcXVlc3RJZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZXNwb25zZXMucHVzaChyZXNwb25zZS5kYXRhLnBhY2tldCk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5taXNzaW5nVWlkcy5kZWxldGUocmVzcG9uc2UudWlkKTtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5taXNzaW5nVWlkcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChyZXF1ZXN0LnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc29sdmUobnVsbCwgcmVxdWVzdC5yZXNwb25zZXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1c3RvbVJlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgc3VwZXIub25SZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlTm9kZSh1aWQpIHtcbiAgICAgICAgdGhpcy5jdXN0b21SZXF1ZXN0cy5mb3JFYWNoKChyZXF1ZXN0LCByZXF1ZXN0SWQpID0+IHtcbiAgICAgICAgICAgIHJlcXVlc3QubWlzc2luZ1VpZHMuZGVsZXRlKHVpZCk7XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5taXNzaW5nVWlkcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHJlcXVlc3QudGltZW91dCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QudHlwZSA9PT0gTWVzc2FnZVR5cGUuRkVUQ0hfU09DS0VUUykge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc29sdmUocmVxdWVzdC5yZXNwb25zZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXF1ZXN0LnR5cGUgPT09IE1lc3NhZ2VUeXBlLlNFUlZFUl9TSURFX0VNSVQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXNvbHZlKG51bGwsIHJlcXVlc3QucmVzcG9uc2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jdXN0b21SZXF1ZXN0cy5kZWxldGUocmVxdWVzdElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubm9kZXNNYXAuZGVsZXRlKHVpZCk7XG4gICAgfVxufVxuZXhwb3J0cy5DbHVzdGVyQWRhcHRlcldpdGhIZWFydGJlYXQgPSBDbHVzdGVyQWRhcHRlcldpdGhIZWFydGJlYXQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/cluster-adapter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/contrib/yeast.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/contrib/yeast.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("// imported from https://github.com/unshiftio/yeast\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.yeast = exports.decode = exports.encode = void 0;\nconst alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_\".split(\"\"), length = 64, map = {};\nlet seed = 0, i = 0, prev;\n/**\n * Return a string representing the specified number.\n *\n * @param {Number} num The number to convert.\n * @returns {String} The string representation of the number.\n * @api public\n */\nfunction encode(num) {\n    let encoded = \"\";\n    do {\n        encoded = alphabet[num % length] + encoded;\n        num = Math.floor(num / length);\n    } while (num > 0);\n    return encoded;\n}\nexports.encode = encode;\n/**\n * Return the integer value specified by the given string.\n *\n * @param {String} str The string to convert.\n * @returns {Number} The integer value represented by the string.\n * @api public\n */\nfunction decode(str) {\n    let decoded = 0;\n    for (i = 0; i < str.length; i++) {\n        decoded = decoded * length + map[str.charAt(i)];\n    }\n    return decoded;\n}\nexports.decode = decode;\n/**\n * Yeast: A tiny growing id generator.\n *\n * @returns {String} A unique id.\n * @api public\n */\nfunction yeast() {\n    const now = encode(+new Date());\n    if (now !== prev)\n        return (seed = 0), (prev = now);\n    return now + \".\" + encode(seed++);\n}\nexports.yeast = yeast;\n//\n// Map each character to its index.\n//\nfor (; i < length; i++)\n    map[alphabet[i]] = i;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vc29ja2V0LmlvLWFkYXB0ZXJAMi41LjUvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1hZGFwdGVyL2Rpc3QvY29udHJpYi95ZWFzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsR0FBRyxjQUFjLEdBQUcsY0FBYztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLE9BQU8sWUFBWTtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvLnBucG0vc29ja2V0LmlvLWFkYXB0ZXJAMi41LjUvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1hZGFwdGVyL2Rpc3QvY29udHJpYi95ZWFzdC5qcz83ODc3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGltcG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3Vuc2hpZnRpby95ZWFzdFxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnllYXN0ID0gZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLmVuY29kZSA9IHZvaWQgMDtcbmNvbnN0IGFscGhhYmV0ID0gXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ei1fXCIuc3BsaXQoXCJcIiksIGxlbmd0aCA9IDY0LCBtYXAgPSB7fTtcbmxldCBzZWVkID0gMCwgaSA9IDAsIHByZXY7XG4vKipcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHNwZWNpZmllZCBudW1iZXIuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBudW1iZXIuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBlbmNvZGUobnVtKSB7XG4gICAgbGV0IGVuY29kZWQgPSBcIlwiO1xuICAgIGRvIHtcbiAgICAgICAgZW5jb2RlZCA9IGFscGhhYmV0W251bSAlIGxlbmd0aF0gKyBlbmNvZGVkO1xuICAgICAgICBudW0gPSBNYXRoLmZsb29yKG51bSAvIGxlbmd0aCk7XG4gICAgfSB3aGlsZSAobnVtID4gMCk7XG4gICAgcmV0dXJuIGVuY29kZWQ7XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbi8qKlxuICogUmV0dXJuIHRoZSBpbnRlZ2VyIHZhbHVlIHNwZWNpZmllZCBieSB0aGUgZ2l2ZW4gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge051bWJlcn0gVGhlIGludGVnZXIgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlIHN0cmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShzdHIpIHtcbiAgICBsZXQgZGVjb2RlZCA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZWNvZGVkID0gZGVjb2RlZCAqIGxlbmd0aCArIG1hcFtzdHIuY2hhckF0KGkpXTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZWQ7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbi8qKlxuICogWWVhc3Q6IEEgdGlueSBncm93aW5nIGlkIGdlbmVyYXRvci5cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBBIHVuaXF1ZSBpZC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHllYXN0KCkge1xuICAgIGNvbnN0IG5vdyA9IGVuY29kZSgrbmV3IERhdGUoKSk7XG4gICAgaWYgKG5vdyAhPT0gcHJldilcbiAgICAgICAgcmV0dXJuIChzZWVkID0gMCksIChwcmV2ID0gbm93KTtcbiAgICByZXR1cm4gbm93ICsgXCIuXCIgKyBlbmNvZGUoc2VlZCsrKTtcbn1cbmV4cG9ydHMueWVhc3QgPSB5ZWFzdDtcbi8vXG4vLyBNYXAgZWFjaCBjaGFyYWN0ZXIgdG8gaXRzIGluZGV4LlxuLy9cbmZvciAoOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgbWFwW2FscGhhYmV0W2ldXSA9IGk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/contrib/yeast.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/in-memory-adapter.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/in-memory-adapter.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar _a;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SessionAwareAdapter = exports.Adapter = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst yeast_1 = __webpack_require__(/*! ./contrib/yeast */ \"(rsc)/./node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/contrib/yeast.js\");\nconst WebSocket = __webpack_require__(/*! ws */ \"(rsc)/./node_modules/.pnpm/ws@8.17.1/node_modules/ws/index.js\");\nconst canPreComputeFrame = typeof ((_a = WebSocket === null || WebSocket === void 0 ? void 0 : WebSocket.Sender) === null || _a === void 0 ? void 0 : _a.frame) === \"function\";\nclass Adapter extends events_1.EventEmitter {\n    /**\n     * In-memory adapter constructor.\n     *\n     * @param {Namespace} nsp\n     */\n    constructor(nsp) {\n        super();\n        this.nsp = nsp;\n        this.rooms = new Map();\n        this.sids = new Map();\n        this.encoder = nsp.server.encoder;\n    }\n    /**\n     * To be overridden\n     */\n    init() { }\n    /**\n     * To be overridden\n     */\n    close() { }\n    /**\n     * Returns the number of Socket.IO servers in the cluster\n     *\n     * @public\n     */\n    serverCount() {\n        return Promise.resolve(1);\n    }\n    /**\n     * Adds a socket to a list of room.\n     *\n     * @param {SocketId}  id      the socket id\n     * @param {Set<Room>} rooms   a set of rooms\n     * @public\n     */\n    addAll(id, rooms) {\n        if (!this.sids.has(id)) {\n            this.sids.set(id, new Set());\n        }\n        for (const room of rooms) {\n            this.sids.get(id).add(room);\n            if (!this.rooms.has(room)) {\n                this.rooms.set(room, new Set());\n                this.emit(\"create-room\", room);\n            }\n            if (!this.rooms.get(room).has(id)) {\n                this.rooms.get(room).add(id);\n                this.emit(\"join-room\", room, id);\n            }\n        }\n    }\n    /**\n     * Removes a socket from a room.\n     *\n     * @param {SocketId} id     the socket id\n     * @param {Room}     room   the room name\n     */\n    del(id, room) {\n        if (this.sids.has(id)) {\n            this.sids.get(id).delete(room);\n        }\n        this._del(room, id);\n    }\n    _del(room, id) {\n        const _room = this.rooms.get(room);\n        if (_room != null) {\n            const deleted = _room.delete(id);\n            if (deleted) {\n                this.emit(\"leave-room\", room, id);\n            }\n            if (_room.size === 0 && this.rooms.delete(room)) {\n                this.emit(\"delete-room\", room);\n            }\n        }\n    }\n    /**\n     * Removes a socket from all rooms it's joined.\n     *\n     * @param {SocketId} id   the socket id\n     */\n    delAll(id) {\n        if (!this.sids.has(id)) {\n            return;\n        }\n        for (const room of this.sids.get(id)) {\n            this._del(room, id);\n        }\n        this.sids.delete(id);\n    }\n    /**\n     * Broadcasts a packet.\n     *\n     * Options:\n     *  - `flags` {Object} flags for this packet\n     *  - `except` {Array} sids that should be excluded\n     *  - `rooms` {Array} list of rooms to broadcast to\n     *\n     * @param {Object} packet   the packet object\n     * @param {Object} opts     the options\n     * @public\n     */\n    broadcast(packet, opts) {\n        const flags = opts.flags || {};\n        const packetOpts = {\n            preEncoded: true,\n            volatile: flags.volatile,\n            compress: flags.compress,\n        };\n        packet.nsp = this.nsp.name;\n        const encodedPackets = this._encode(packet, packetOpts);\n        this.apply(opts, (socket) => {\n            if (typeof socket.notifyOutgoingListeners === \"function\") {\n                socket.notifyOutgoingListeners(packet);\n            }\n            socket.client.writeToEngine(encodedPackets, packetOpts);\n        });\n    }\n    /**\n     * Broadcasts a packet and expects multiple acknowledgements.\n     *\n     * Options:\n     *  - `flags` {Object} flags for this packet\n     *  - `except` {Array} sids that should be excluded\n     *  - `rooms` {Array} list of rooms to broadcast to\n     *\n     * @param {Object} packet   the packet object\n     * @param {Object} opts     the options\n     * @param clientCountCallback - the number of clients that received the packet\n     * @param ack                 - the callback that will be called for each client response\n     *\n     * @public\n     */\n    broadcastWithAck(packet, opts, clientCountCallback, ack) {\n        const flags = opts.flags || {};\n        const packetOpts = {\n            preEncoded: true,\n            volatile: flags.volatile,\n            compress: flags.compress,\n        };\n        packet.nsp = this.nsp.name;\n        // we can use the same id for each packet, since the _ids counter is common (no duplicate)\n        packet.id = this.nsp._ids++;\n        const encodedPackets = this._encode(packet, packetOpts);\n        let clientCount = 0;\n        this.apply(opts, (socket) => {\n            // track the total number of acknowledgements that are expected\n            clientCount++;\n            // call the ack callback for each client response\n            socket.acks.set(packet.id, ack);\n            if (typeof socket.notifyOutgoingListeners === \"function\") {\n                socket.notifyOutgoingListeners(packet);\n            }\n            socket.client.writeToEngine(encodedPackets, packetOpts);\n        });\n        clientCountCallback(clientCount);\n    }\n    _encode(packet, packetOpts) {\n        const encodedPackets = this.encoder.encode(packet);\n        if (canPreComputeFrame &&\n            encodedPackets.length === 1 &&\n            typeof encodedPackets[0] === \"string\") {\n            // \"4\" being the \"message\" packet type in the Engine.IO protocol\n            const data = Buffer.from(\"4\" + encodedPackets[0]);\n            // see https://github.com/websockets/ws/issues/617#issuecomment-283002469\n            packetOpts.wsPreEncodedFrame = WebSocket.Sender.frame(data, {\n                readOnly: false,\n                mask: false,\n                rsv1: false,\n                opcode: 1,\n                fin: true,\n            });\n        }\n        return encodedPackets;\n    }\n    /**\n     * Gets a list of sockets by sid.\n     *\n     * @param {Set<Room>} rooms   the explicit set of rooms to check.\n     */\n    sockets(rooms) {\n        const sids = new Set();\n        this.apply({ rooms }, (socket) => {\n            sids.add(socket.id);\n        });\n        return Promise.resolve(sids);\n    }\n    /**\n     * Gets the list of rooms a given socket has joined.\n     *\n     * @param {SocketId} id   the socket id\n     */\n    socketRooms(id) {\n        return this.sids.get(id);\n    }\n    /**\n     * Returns the matching socket instances\n     *\n     * @param opts - the filters to apply\n     */\n    fetchSockets(opts) {\n        const sockets = [];\n        this.apply(opts, (socket) => {\n            sockets.push(socket);\n        });\n        return Promise.resolve(sockets);\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms\n     *\n     * @param opts - the filters to apply\n     * @param rooms - the rooms to join\n     */\n    addSockets(opts, rooms) {\n        this.apply(opts, (socket) => {\n            socket.join(rooms);\n        });\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms\n     *\n     * @param opts - the filters to apply\n     * @param rooms - the rooms to leave\n     */\n    delSockets(opts, rooms) {\n        this.apply(opts, (socket) => {\n            rooms.forEach((room) => socket.leave(room));\n        });\n    }\n    /**\n     * Makes the matching socket instances disconnect\n     *\n     * @param opts - the filters to apply\n     * @param close - whether to close the underlying connection\n     */\n    disconnectSockets(opts, close) {\n        this.apply(opts, (socket) => {\n            socket.disconnect(close);\n        });\n    }\n    apply(opts, callback) {\n        const rooms = opts.rooms;\n        const except = this.computeExceptSids(opts.except);\n        if (rooms.size) {\n            const ids = new Set();\n            for (const room of rooms) {\n                if (!this.rooms.has(room))\n                    continue;\n                for (const id of this.rooms.get(room)) {\n                    if (ids.has(id) || except.has(id))\n                        continue;\n                    const socket = this.nsp.sockets.get(id);\n                    if (socket) {\n                        callback(socket);\n                        ids.add(id);\n                    }\n                }\n            }\n        }\n        else {\n            for (const [id] of this.sids) {\n                if (except.has(id))\n                    continue;\n                const socket = this.nsp.sockets.get(id);\n                if (socket)\n                    callback(socket);\n            }\n        }\n    }\n    computeExceptSids(exceptRooms) {\n        const exceptSids = new Set();\n        if (exceptRooms && exceptRooms.size > 0) {\n            for (const room of exceptRooms) {\n                if (this.rooms.has(room)) {\n                    this.rooms.get(room).forEach((sid) => exceptSids.add(sid));\n                }\n            }\n        }\n        return exceptSids;\n    }\n    /**\n     * Send a packet to the other Socket.IO servers in the cluster\n     * @param packet - an array of arguments, which may include an acknowledgement callback at the end\n     */\n    serverSideEmit(packet) {\n        console.warn(\"this adapter does not support the serverSideEmit() functionality\");\n    }\n    /**\n     * Save the client session in order to restore it upon reconnection.\n     */\n    persistSession(session) { }\n    /**\n     * Restore the session and find the packets that were missed by the client.\n     * @param pid\n     * @param offset\n     */\n    restoreSession(pid, offset) {\n        return null;\n    }\n}\nexports.Adapter = Adapter;\nclass SessionAwareAdapter extends Adapter {\n    constructor(nsp) {\n        super(nsp);\n        this.nsp = nsp;\n        this.sessions = new Map();\n        this.packets = [];\n        this.maxDisconnectionDuration =\n            nsp.server.opts.connectionStateRecovery.maxDisconnectionDuration;\n        const timer = setInterval(() => {\n            const threshold = Date.now() - this.maxDisconnectionDuration;\n            this.sessions.forEach((session, sessionId) => {\n                const hasExpired = session.disconnectedAt < threshold;\n                if (hasExpired) {\n                    this.sessions.delete(sessionId);\n                }\n            });\n            for (let i = this.packets.length - 1; i >= 0; i--) {\n                const hasExpired = this.packets[i].emittedAt < threshold;\n                if (hasExpired) {\n                    this.packets.splice(0, i + 1);\n                    break;\n                }\n            }\n        }, 60 * 1000);\n        // prevents the timer from keeping the process alive\n        timer.unref();\n    }\n    persistSession(session) {\n        session.disconnectedAt = Date.now();\n        this.sessions.set(session.pid, session);\n    }\n    restoreSession(pid, offset) {\n        const session = this.sessions.get(pid);\n        if (!session) {\n            // the session may have expired\n            return null;\n        }\n        const hasExpired = session.disconnectedAt + this.maxDisconnectionDuration < Date.now();\n        if (hasExpired) {\n            // the session has expired\n            this.sessions.delete(pid);\n            return null;\n        }\n        const index = this.packets.findIndex((packet) => packet.id === offset);\n        if (index === -1) {\n            // the offset may be too old\n            return null;\n        }\n        const missedPackets = [];\n        for (let i = index + 1; i < this.packets.length; i++) {\n            const packet = this.packets[i];\n            if (shouldIncludePacket(session.rooms, packet.opts)) {\n                missedPackets.push(packet.data);\n            }\n        }\n        return Promise.resolve(Object.assign(Object.assign({}, session), { missedPackets }));\n    }\n    broadcast(packet, opts) {\n        var _a;\n        const isEventPacket = packet.type === 2;\n        // packets with acknowledgement are not stored because the acknowledgement function cannot be serialized and\n        // restored on another server upon reconnection\n        const withoutAcknowledgement = packet.id === undefined;\n        const notVolatile = ((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.volatile) === undefined;\n        if (isEventPacket && withoutAcknowledgement && notVolatile) {\n            const id = (0, yeast_1.yeast)();\n            // the offset is stored at the end of the data array, so the client knows the ID of the last packet it has\n            // processed (and the format is backward-compatible)\n            packet.data.push(id);\n            this.packets.push({\n                id,\n                opts,\n                data: packet.data,\n                emittedAt: Date.now(),\n            });\n        }\n        super.broadcast(packet, opts);\n    }\n}\nexports.SessionAwareAdapter = SessionAwareAdapter;\nfunction shouldIncludePacket(sessionRooms, opts) {\n    const included = opts.rooms.size === 0 || sessionRooms.some((room) => opts.rooms.has(room));\n    const notExcluded = sessionRooms.every((room) => !opts.except.has(room));\n    return included && notExcluded;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vc29ja2V0LmlvLWFkYXB0ZXJAMi41LjUvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1hZGFwdGVyL2Rpc3QvaW4tbWVtb3J5LWFkYXB0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRyxlQUFlO0FBQzdDLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLGdJQUFpQjtBQUN6QyxrQkFBa0IsbUJBQU8sQ0FBQyx5RUFBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CLE9BQU87QUFDM0IsbUJBQW1CLE9BQU87QUFDMUI7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixvQkFBb0IsT0FBTztBQUMzQixtQkFBbUIsT0FBTztBQUMxQjtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixrREFBa0QsUUFBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MseUJBQXlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYyxlQUFlO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktdjAtcHJvamVjdC8uL25vZGVfbW9kdWxlcy8ucG5wbS9zb2NrZXQuaW8tYWRhcHRlckAyLjUuNS9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvZGlzdC9pbi1tZW1vcnktYWRhcHRlci5qcz9jYzU1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9hO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZXNzaW9uQXdhcmVBZGFwdGVyID0gZXhwb3J0cy5BZGFwdGVyID0gdm9pZCAwO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgeWVhc3RfMSA9IHJlcXVpcmUoXCIuL2NvbnRyaWIveWVhc3RcIik7XG5jb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKFwid3NcIik7XG5jb25zdCBjYW5QcmVDb21wdXRlRnJhbWUgPSB0eXBlb2YgKChfYSA9IFdlYlNvY2tldCA9PT0gbnVsbCB8fCBXZWJTb2NrZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IFdlYlNvY2tldC5TZW5kZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mcmFtZSkgPT09IFwiZnVuY3Rpb25cIjtcbmNsYXNzIEFkYXB0ZXIgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIEluLW1lbW9yeSBhZGFwdGVyIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOYW1lc3BhY2V9IG5zcFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5zcCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5zcCA9IG5zcDtcbiAgICAgICAgdGhpcy5yb29tcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zaWRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmVuY29kZXIgPSBuc3Auc2VydmVyLmVuY29kZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvIGJlIG92ZXJyaWRkZW5cbiAgICAgKi9cbiAgICBpbml0KCkgeyB9XG4gICAgLyoqXG4gICAgICogVG8gYmUgb3ZlcnJpZGRlblxuICAgICAqL1xuICAgIGNsb3NlKCkgeyB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIFNvY2tldC5JTyBzZXJ2ZXJzIGluIHRoZSBjbHVzdGVyXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc2VydmVyQ291bnQoKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzb2NrZXQgdG8gYSBsaXN0IG9mIHJvb20uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NvY2tldElkfSAgaWQgICAgICB0aGUgc29ja2V0IGlkXG4gICAgICogQHBhcmFtIHtTZXQ8Um9vbT59IHJvb21zICAgYSBzZXQgb2Ygcm9vbXNcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgYWRkQWxsKGlkLCByb29tcykge1xuICAgICAgICBpZiAoIXRoaXMuc2lkcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB0aGlzLnNpZHMuc2V0KGlkLCBuZXcgU2V0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgcm9vbSBvZiByb29tcykge1xuICAgICAgICAgICAgdGhpcy5zaWRzLmdldChpZCkuYWRkKHJvb20pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJvb21zLmhhcyhyb29tKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucm9vbXMuc2V0KHJvb20sIG5ldyBTZXQoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiY3JlYXRlLXJvb21cIiwgcm9vbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMucm9vbXMuZ2V0KHJvb20pLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb21zLmdldChyb29tKS5hZGQoaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImpvaW4tcm9vbVwiLCByb29tLCBpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHNvY2tldCBmcm9tIGEgcm9vbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U29ja2V0SWR9IGlkICAgICB0aGUgc29ja2V0IGlkXG4gICAgICogQHBhcmFtIHtSb29tfSAgICAgcm9vbSAgIHRoZSByb29tIG5hbWVcbiAgICAgKi9cbiAgICBkZWwoaWQsIHJvb20pIHtcbiAgICAgICAgaWYgKHRoaXMuc2lkcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB0aGlzLnNpZHMuZ2V0KGlkKS5kZWxldGUocm9vbSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGVsKHJvb20sIGlkKTtcbiAgICB9XG4gICAgX2RlbChyb29tLCBpZCkge1xuICAgICAgICBjb25zdCBfcm9vbSA9IHRoaXMucm9vbXMuZ2V0KHJvb20pO1xuICAgICAgICBpZiAoX3Jvb20gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZGVsZXRlZCA9IF9yb29tLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICBpZiAoZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImxlYXZlLXJvb21cIiwgcm9vbSwgaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9yb29tLnNpemUgPT09IDAgJiYgdGhpcy5yb29tcy5kZWxldGUocm9vbSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWxldGUtcm9vbVwiLCByb29tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgc29ja2V0IGZyb20gYWxsIHJvb21zIGl0J3Mgam9pbmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTb2NrZXRJZH0gaWQgICB0aGUgc29ja2V0IGlkXG4gICAgICovXG4gICAgZGVsQWxsKGlkKSB7XG4gICAgICAgIGlmICghdGhpcy5zaWRzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHJvb20gb2YgdGhpcy5zaWRzLmdldChpZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlbChyb29tLCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaWRzLmRlbGV0ZShpZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJyb2FkY2FzdHMgYSBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBPcHRpb25zOlxuICAgICAqICAtIGBmbGFnc2Age09iamVjdH0gZmxhZ3MgZm9yIHRoaXMgcGFja2V0XG4gICAgICogIC0gYGV4Y2VwdGAge0FycmF5fSBzaWRzIHRoYXQgc2hvdWxkIGJlIGV4Y2x1ZGVkXG4gICAgICogIC0gYHJvb21zYCB7QXJyYXl9IGxpc3Qgb2Ygcm9vbXMgdG8gYnJvYWRjYXN0IHRvXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0ICAgdGhlIHBhY2tldCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAgICAgdGhlIG9wdGlvbnNcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgYnJvYWRjYXN0KHBhY2tldCwgb3B0cykge1xuICAgICAgICBjb25zdCBmbGFncyA9IG9wdHMuZmxhZ3MgfHwge307XG4gICAgICAgIGNvbnN0IHBhY2tldE9wdHMgPSB7XG4gICAgICAgICAgICBwcmVFbmNvZGVkOiB0cnVlLFxuICAgICAgICAgICAgdm9sYXRpbGU6IGZsYWdzLnZvbGF0aWxlLFxuICAgICAgICAgICAgY29tcHJlc3M6IGZsYWdzLmNvbXByZXNzLFxuICAgICAgICB9O1xuICAgICAgICBwYWNrZXQubnNwID0gdGhpcy5uc3AubmFtZTtcbiAgICAgICAgY29uc3QgZW5jb2RlZFBhY2tldHMgPSB0aGlzLl9lbmNvZGUocGFja2V0LCBwYWNrZXRPcHRzKTtcbiAgICAgICAgdGhpcy5hcHBseShvcHRzLCAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNvY2tldC5ub3RpZnlPdXRnb2luZ0xpc3RlbmVycyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgc29ja2V0Lm5vdGlmeU91dGdvaW5nTGlzdGVuZXJzKHBhY2tldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb2NrZXQuY2xpZW50LndyaXRlVG9FbmdpbmUoZW5jb2RlZFBhY2tldHMsIHBhY2tldE9wdHMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnJvYWRjYXN0cyBhIHBhY2tldCBhbmQgZXhwZWN0cyBtdWx0aXBsZSBhY2tub3dsZWRnZW1lbnRzLlxuICAgICAqXG4gICAgICogT3B0aW9uczpcbiAgICAgKiAgLSBgZmxhZ3NgIHtPYmplY3R9IGZsYWdzIGZvciB0aGlzIHBhY2tldFxuICAgICAqICAtIGBleGNlcHRgIHtBcnJheX0gc2lkcyB0aGF0IHNob3VsZCBiZSBleGNsdWRlZFxuICAgICAqICAtIGByb29tc2Age0FycmF5fSBsaXN0IG9mIHJvb21zIHRvIGJyb2FkY2FzdCB0b1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAgIHRoZSBwYWNrZXQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgICAgIHRoZSBvcHRpb25zXG4gICAgICogQHBhcmFtIGNsaWVudENvdW50Q2FsbGJhY2sgLSB0aGUgbnVtYmVyIG9mIGNsaWVudHMgdGhhdCByZWNlaXZlZCB0aGUgcGFja2V0XG4gICAgICogQHBhcmFtIGFjayAgICAgICAgICAgICAgICAgLSB0aGUgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBjbGllbnQgcmVzcG9uc2VcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBicm9hZGNhc3RXaXRoQWNrKHBhY2tldCwgb3B0cywgY2xpZW50Q291bnRDYWxsYmFjaywgYWNrKSB7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gb3B0cy5mbGFncyB8fCB7fTtcbiAgICAgICAgY29uc3QgcGFja2V0T3B0cyA9IHtcbiAgICAgICAgICAgIHByZUVuY29kZWQ6IHRydWUsXG4gICAgICAgICAgICB2b2xhdGlsZTogZmxhZ3Mudm9sYXRpbGUsXG4gICAgICAgICAgICBjb21wcmVzczogZmxhZ3MuY29tcHJlc3MsXG4gICAgICAgIH07XG4gICAgICAgIHBhY2tldC5uc3AgPSB0aGlzLm5zcC5uYW1lO1xuICAgICAgICAvLyB3ZSBjYW4gdXNlIHRoZSBzYW1lIGlkIGZvciBlYWNoIHBhY2tldCwgc2luY2UgdGhlIF9pZHMgY291bnRlciBpcyBjb21tb24gKG5vIGR1cGxpY2F0ZSlcbiAgICAgICAgcGFja2V0LmlkID0gdGhpcy5uc3AuX2lkcysrO1xuICAgICAgICBjb25zdCBlbmNvZGVkUGFja2V0cyA9IHRoaXMuX2VuY29kZShwYWNrZXQsIHBhY2tldE9wdHMpO1xuICAgICAgICBsZXQgY2xpZW50Q291bnQgPSAwO1xuICAgICAgICB0aGlzLmFwcGx5KG9wdHMsIChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgIC8vIHRyYWNrIHRoZSB0b3RhbCBudW1iZXIgb2YgYWNrbm93bGVkZ2VtZW50cyB0aGF0IGFyZSBleHBlY3RlZFxuICAgICAgICAgICAgY2xpZW50Q291bnQrKztcbiAgICAgICAgICAgIC8vIGNhbGwgdGhlIGFjayBjYWxsYmFjayBmb3IgZWFjaCBjbGllbnQgcmVzcG9uc2VcbiAgICAgICAgICAgIHNvY2tldC5hY2tzLnNldChwYWNrZXQuaWQsIGFjayk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNvY2tldC5ub3RpZnlPdXRnb2luZ0xpc3RlbmVycyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgc29ja2V0Lm5vdGlmeU91dGdvaW5nTGlzdGVuZXJzKHBhY2tldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb2NrZXQuY2xpZW50LndyaXRlVG9FbmdpbmUoZW5jb2RlZFBhY2tldHMsIHBhY2tldE9wdHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgY2xpZW50Q291bnRDYWxsYmFjayhjbGllbnRDb3VudCk7XG4gICAgfVxuICAgIF9lbmNvZGUocGFja2V0LCBwYWNrZXRPcHRzKSB7XG4gICAgICAgIGNvbnN0IGVuY29kZWRQYWNrZXRzID0gdGhpcy5lbmNvZGVyLmVuY29kZShwYWNrZXQpO1xuICAgICAgICBpZiAoY2FuUHJlQ29tcHV0ZUZyYW1lICYmXG4gICAgICAgICAgICBlbmNvZGVkUGFja2V0cy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgIHR5cGVvZiBlbmNvZGVkUGFja2V0c1swXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gXCI0XCIgYmVpbmcgdGhlIFwibWVzc2FnZVwiIHBhY2tldCB0eXBlIGluIHRoZSBFbmdpbmUuSU8gcHJvdG9jb2xcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBCdWZmZXIuZnJvbShcIjRcIiArIGVuY29kZWRQYWNrZXRzWzBdKTtcbiAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvNjE3I2lzc3VlY29tbWVudC0yODMwMDI0NjlcbiAgICAgICAgICAgIHBhY2tldE9wdHMud3NQcmVFbmNvZGVkRnJhbWUgPSBXZWJTb2NrZXQuU2VuZGVyLmZyYW1lKGRhdGEsIHtcbiAgICAgICAgICAgICAgICByZWFkT25seTogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWFzazogZmFsc2UsXG4gICAgICAgICAgICAgICAgcnN2MTogZmFsc2UsXG4gICAgICAgICAgICAgICAgb3Bjb2RlOiAxLFxuICAgICAgICAgICAgICAgIGZpbjogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmNvZGVkUGFja2V0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGxpc3Qgb2Ygc29ja2V0cyBieSBzaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NldDxSb29tPn0gcm9vbXMgICB0aGUgZXhwbGljaXQgc2V0IG9mIHJvb21zIHRvIGNoZWNrLlxuICAgICAqL1xuICAgIHNvY2tldHMocm9vbXMpIHtcbiAgICAgICAgY29uc3Qgc2lkcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5hcHBseSh7IHJvb21zIH0sIChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgIHNpZHMuYWRkKHNvY2tldC5pZCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNpZHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsaXN0IG9mIHJvb21zIGEgZ2l2ZW4gc29ja2V0IGhhcyBqb2luZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NvY2tldElkfSBpZCAgIHRoZSBzb2NrZXQgaWRcbiAgICAgKi9cbiAgICBzb2NrZXRSb29tcyhpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWRzLmdldChpZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIC0gdGhlIGZpbHRlcnMgdG8gYXBwbHlcbiAgICAgKi9cbiAgICBmZXRjaFNvY2tldHMob3B0cykge1xuICAgICAgICBjb25zdCBzb2NrZXRzID0gW107XG4gICAgICAgIHRoaXMuYXBwbHkob3B0cywgKHNvY2tldCkgPT4ge1xuICAgICAgICAgICAgc29ja2V0cy5wdXNoKHNvY2tldCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNvY2tldHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcyBqb2luIHRoZSBzcGVjaWZpZWQgcm9vbXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIC0gdGhlIGZpbHRlcnMgdG8gYXBwbHlcbiAgICAgKiBAcGFyYW0gcm9vbXMgLSB0aGUgcm9vbXMgdG8gam9pblxuICAgICAqL1xuICAgIGFkZFNvY2tldHMob3B0cywgcm9vbXMpIHtcbiAgICAgICAgdGhpcy5hcHBseShvcHRzLCAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICBzb2NrZXQuam9pbihyb29tcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcyBsZWF2ZSB0aGUgc3BlY2lmaWVkIHJvb21zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyAtIHRoZSBmaWx0ZXJzIHRvIGFwcGx5XG4gICAgICogQHBhcmFtIHJvb21zIC0gdGhlIHJvb21zIHRvIGxlYXZlXG4gICAgICovXG4gICAgZGVsU29ja2V0cyhvcHRzLCByb29tcykge1xuICAgICAgICB0aGlzLmFwcGx5KG9wdHMsIChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgIHJvb21zLmZvckVhY2goKHJvb20pID0+IHNvY2tldC5sZWF2ZShyb29tKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcyBkaXNjb25uZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyAtIHRoZSBmaWx0ZXJzIHRvIGFwcGx5XG4gICAgICogQHBhcmFtIGNsb3NlIC0gd2hldGhlciB0byBjbG9zZSB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uXG4gICAgICovXG4gICAgZGlzY29ubmVjdFNvY2tldHMob3B0cywgY2xvc2UpIHtcbiAgICAgICAgdGhpcy5hcHBseShvcHRzLCAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICBzb2NrZXQuZGlzY29ubmVjdChjbG9zZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhcHBseShvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCByb29tcyA9IG9wdHMucm9vbXM7XG4gICAgICAgIGNvbnN0IGV4Y2VwdCA9IHRoaXMuY29tcHV0ZUV4Y2VwdFNpZHMob3B0cy5leGNlcHQpO1xuICAgICAgICBpZiAocm9vbXMuc2l6ZSkge1xuICAgICAgICAgICAgY29uc3QgaWRzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCByb29tIG9mIHJvb21zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJvb21zLmhhcyhyb29tKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpZCBvZiB0aGlzLnJvb21zLmdldChyb29tKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWRzLmhhcyhpZCkgfHwgZXhjZXB0LmhhcyhpZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc29ja2V0ID0gdGhpcy5uc3Auc29ja2V0cy5nZXQoaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc29ja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhzb2NrZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWRzLmFkZChpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtpZF0gb2YgdGhpcy5zaWRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4Y2VwdC5oYXMoaWQpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBzb2NrZXQgPSB0aGlzLm5zcC5zb2NrZXRzLmdldChpZCk7XG4gICAgICAgICAgICAgICAgaWYgKHNvY2tldClcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soc29ja2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wdXRlRXhjZXB0U2lkcyhleGNlcHRSb29tcykge1xuICAgICAgICBjb25zdCBleGNlcHRTaWRzID0gbmV3IFNldCgpO1xuICAgICAgICBpZiAoZXhjZXB0Um9vbXMgJiYgZXhjZXB0Um9vbXMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgcm9vbSBvZiBleGNlcHRSb29tcykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJvb21zLmhhcyhyb29tKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb21zLmdldChyb29tKS5mb3JFYWNoKChzaWQpID0+IGV4Y2VwdFNpZHMuYWRkKHNpZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhjZXB0U2lkcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhIHBhY2tldCB0byB0aGUgb3RoZXIgU29ja2V0LklPIHNlcnZlcnMgaW4gdGhlIGNsdXN0ZXJcbiAgICAgKiBAcGFyYW0gcGFja2V0IC0gYW4gYXJyYXkgb2YgYXJndW1lbnRzLCB3aGljaCBtYXkgaW5jbHVkZSBhbiBhY2tub3dsZWRnZW1lbnQgY2FsbGJhY2sgYXQgdGhlIGVuZFxuICAgICAqL1xuICAgIHNlcnZlclNpZGVFbWl0KHBhY2tldCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJ0aGlzIGFkYXB0ZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgc2VydmVyU2lkZUVtaXQoKSBmdW5jdGlvbmFsaXR5XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTYXZlIHRoZSBjbGllbnQgc2Vzc2lvbiBpbiBvcmRlciB0byByZXN0b3JlIGl0IHVwb24gcmVjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIHBlcnNpc3RTZXNzaW9uKHNlc3Npb24pIHsgfVxuICAgIC8qKlxuICAgICAqIFJlc3RvcmUgdGhlIHNlc3Npb24gYW5kIGZpbmQgdGhlIHBhY2tldHMgdGhhdCB3ZXJlIG1pc3NlZCBieSB0aGUgY2xpZW50LlxuICAgICAqIEBwYXJhbSBwaWRcbiAgICAgKiBAcGFyYW0gb2Zmc2V0XG4gICAgICovXG4gICAgcmVzdG9yZVNlc3Npb24ocGlkLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5BZGFwdGVyID0gQWRhcHRlcjtcbmNsYXNzIFNlc3Npb25Bd2FyZUFkYXB0ZXIgZXh0ZW5kcyBBZGFwdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihuc3ApIHtcbiAgICAgICAgc3VwZXIobnNwKTtcbiAgICAgICAgdGhpcy5uc3AgPSBuc3A7XG4gICAgICAgIHRoaXMuc2Vzc2lvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucGFja2V0cyA9IFtdO1xuICAgICAgICB0aGlzLm1heERpc2Nvbm5lY3Rpb25EdXJhdGlvbiA9XG4gICAgICAgICAgICBuc3Auc2VydmVyLm9wdHMuY29ubmVjdGlvblN0YXRlUmVjb3ZlcnkubWF4RGlzY29ubmVjdGlvbkR1cmF0aW9uO1xuICAgICAgICBjb25zdCB0aW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRocmVzaG9sZCA9IERhdGUubm93KCkgLSB0aGlzLm1heERpc2Nvbm5lY3Rpb25EdXJhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbnMuZm9yRWFjaCgoc2Vzc2lvbiwgc2Vzc2lvbklkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzRXhwaXJlZCA9IHNlc3Npb24uZGlzY29ubmVjdGVkQXQgPCB0aHJlc2hvbGQ7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0V4cGlyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9ucy5kZWxldGUoc2Vzc2lvbklkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnBhY2tldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNFeHBpcmVkID0gdGhpcy5wYWNrZXRzW2ldLmVtaXR0ZWRBdCA8IHRocmVzaG9sZDtcbiAgICAgICAgICAgICAgICBpZiAoaGFzRXhwaXJlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhY2tldHMuc3BsaWNlKDAsIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCA2MCAqIDEwMDApO1xuICAgICAgICAvLyBwcmV2ZW50cyB0aGUgdGltZXIgZnJvbSBrZWVwaW5nIHRoZSBwcm9jZXNzIGFsaXZlXG4gICAgICAgIHRpbWVyLnVucmVmKCk7XG4gICAgfVxuICAgIHBlcnNpc3RTZXNzaW9uKHNlc3Npb24pIHtcbiAgICAgICAgc2Vzc2lvbi5kaXNjb25uZWN0ZWRBdCA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbnMuc2V0KHNlc3Npb24ucGlkLCBzZXNzaW9uKTtcbiAgICB9XG4gICAgcmVzdG9yZVNlc3Npb24ocGlkLCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbnMuZ2V0KHBpZCk7XG4gICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgLy8gdGhlIHNlc3Npb24gbWF5IGhhdmUgZXhwaXJlZFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzRXhwaXJlZCA9IHNlc3Npb24uZGlzY29ubmVjdGVkQXQgKyB0aGlzLm1heERpc2Nvbm5lY3Rpb25EdXJhdGlvbiA8IERhdGUubm93KCk7XG4gICAgICAgIGlmIChoYXNFeHBpcmVkKSB7XG4gICAgICAgICAgICAvLyB0aGUgc2Vzc2lvbiBoYXMgZXhwaXJlZFxuICAgICAgICAgICAgdGhpcy5zZXNzaW9ucy5kZWxldGUocGlkKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5wYWNrZXRzLmZpbmRJbmRleCgocGFja2V0KSA9PiBwYWNrZXQuaWQgPT09IG9mZnNldCk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIHRoZSBvZmZzZXQgbWF5IGJlIHRvbyBvbGRcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1pc3NlZFBhY2tldHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4ICsgMTsgaSA8IHRoaXMucGFja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcGFja2V0ID0gdGhpcy5wYWNrZXRzW2ldO1xuICAgICAgICAgICAgaWYgKHNob3VsZEluY2x1ZGVQYWNrZXQoc2Vzc2lvbi5yb29tcywgcGFja2V0Lm9wdHMpKSB7XG4gICAgICAgICAgICAgICAgbWlzc2VkUGFja2V0cy5wdXNoKHBhY2tldC5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2Vzc2lvbiksIHsgbWlzc2VkUGFja2V0cyB9KSk7XG4gICAgfVxuICAgIGJyb2FkY2FzdChwYWNrZXQsIG9wdHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBpc0V2ZW50UGFja2V0ID0gcGFja2V0LnR5cGUgPT09IDI7XG4gICAgICAgIC8vIHBhY2tldHMgd2l0aCBhY2tub3dsZWRnZW1lbnQgYXJlIG5vdCBzdG9yZWQgYmVjYXVzZSB0aGUgYWNrbm93bGVkZ2VtZW50IGZ1bmN0aW9uIGNhbm5vdCBiZSBzZXJpYWxpemVkIGFuZFxuICAgICAgICAvLyByZXN0b3JlZCBvbiBhbm90aGVyIHNlcnZlciB1cG9uIHJlY29ubmVjdGlvblxuICAgICAgICBjb25zdCB3aXRob3V0QWNrbm93bGVkZ2VtZW50ID0gcGFja2V0LmlkID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IG5vdFZvbGF0aWxlID0gKChfYSA9IG9wdHMuZmxhZ3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52b2xhdGlsZSkgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGlzRXZlbnRQYWNrZXQgJiYgd2l0aG91dEFja25vd2xlZGdlbWVudCAmJiBub3RWb2xhdGlsZSkge1xuICAgICAgICAgICAgY29uc3QgaWQgPSAoMCwgeWVhc3RfMS55ZWFzdCkoKTtcbiAgICAgICAgICAgIC8vIHRoZSBvZmZzZXQgaXMgc3RvcmVkIGF0IHRoZSBlbmQgb2YgdGhlIGRhdGEgYXJyYXksIHNvIHRoZSBjbGllbnQga25vd3MgdGhlIElEIG9mIHRoZSBsYXN0IHBhY2tldCBpdCBoYXNcbiAgICAgICAgICAgIC8vIHByb2Nlc3NlZCAoYW5kIHRoZSBmb3JtYXQgaXMgYmFja3dhcmQtY29tcGF0aWJsZSlcbiAgICAgICAgICAgIHBhY2tldC5kYXRhLnB1c2goaWQpO1xuICAgICAgICAgICAgdGhpcy5wYWNrZXRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG9wdHMsXG4gICAgICAgICAgICAgICAgZGF0YTogcGFja2V0LmRhdGEsXG4gICAgICAgICAgICAgICAgZW1pdHRlZEF0OiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuYnJvYWRjYXN0KHBhY2tldCwgb3B0cyk7XG4gICAgfVxufVxuZXhwb3J0cy5TZXNzaW9uQXdhcmVBZGFwdGVyID0gU2Vzc2lvbkF3YXJlQWRhcHRlcjtcbmZ1bmN0aW9uIHNob3VsZEluY2x1ZGVQYWNrZXQoc2Vzc2lvblJvb21zLCBvcHRzKSB7XG4gICAgY29uc3QgaW5jbHVkZWQgPSBvcHRzLnJvb21zLnNpemUgPT09IDAgfHwgc2Vzc2lvblJvb21zLnNvbWUoKHJvb20pID0+IG9wdHMucm9vbXMuaGFzKHJvb20pKTtcbiAgICBjb25zdCBub3RFeGNsdWRlZCA9IHNlc3Npb25Sb29tcy5ldmVyeSgocm9vbSkgPT4gIW9wdHMuZXhjZXB0Lmhhcyhyb29tKSk7XG4gICAgcmV0dXJuIGluY2x1ZGVkICYmIG5vdEV4Y2x1ZGVkO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/in-memory-adapter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/index.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/index.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MessageType = exports.ClusterAdapterWithHeartbeat = exports.ClusterAdapter = exports.SessionAwareAdapter = exports.Adapter = void 0;\nvar in_memory_adapter_1 = __webpack_require__(/*! ./in-memory-adapter */ \"(rsc)/./node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/in-memory-adapter.js\");\nObject.defineProperty(exports, \"Adapter\", ({ enumerable: true, get: function () { return in_memory_adapter_1.Adapter; } }));\nObject.defineProperty(exports, \"SessionAwareAdapter\", ({ enumerable: true, get: function () { return in_memory_adapter_1.SessionAwareAdapter; } }));\nvar cluster_adapter_1 = __webpack_require__(/*! ./cluster-adapter */ \"(rsc)/./node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/cluster-adapter.js\");\nObject.defineProperty(exports, \"ClusterAdapter\", ({ enumerable: true, get: function () { return cluster_adapter_1.ClusterAdapter; } }));\nObject.defineProperty(exports, \"ClusterAdapterWithHeartbeat\", ({ enumerable: true, get: function () { return cluster_adapter_1.ClusterAdapterWithHeartbeat; } }));\nObject.defineProperty(exports, \"MessageType\", ({ enumerable: true, get: function () { return cluster_adapter_1.MessageType; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vc29ja2V0LmlvLWFkYXB0ZXJAMi41LjUvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1hZGFwdGVyL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsbUNBQW1DLEdBQUcsc0JBQXNCLEdBQUcsMkJBQTJCLEdBQUcsZUFBZTtBQUNsSSwwQkFBMEIsbUJBQU8sQ0FBQyx3SUFBcUI7QUFDdkQsMkNBQTBDLEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ3pILHVEQUFzRCxFQUFFLHFDQUFxQyxtREFBbUQsRUFBQztBQUNqSix3QkFBd0IsbUJBQU8sQ0FBQyxvSUFBbUI7QUFDbkQsa0RBQWlELEVBQUUscUNBQXFDLDRDQUE0QyxFQUFDO0FBQ3JJLCtEQUE4RCxFQUFFLHFDQUFxQyx5REFBeUQsRUFBQztBQUMvSiwrQ0FBOEMsRUFBRSxxQ0FBcUMseUNBQXlDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL3NvY2tldC5pby1hZGFwdGVyQDIuNS41L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tYWRhcHRlci9kaXN0L2luZGV4LmpzPzU4NzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1lc3NhZ2VUeXBlID0gZXhwb3J0cy5DbHVzdGVyQWRhcHRlcldpdGhIZWFydGJlYXQgPSBleHBvcnRzLkNsdXN0ZXJBZGFwdGVyID0gZXhwb3J0cy5TZXNzaW9uQXdhcmVBZGFwdGVyID0gZXhwb3J0cy5BZGFwdGVyID0gdm9pZCAwO1xudmFyIGluX21lbW9yeV9hZGFwdGVyXzEgPSByZXF1aXJlKFwiLi9pbi1tZW1vcnktYWRhcHRlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFkYXB0ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluX21lbW9yeV9hZGFwdGVyXzEuQWRhcHRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlc3Npb25Bd2FyZUFkYXB0ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluX21lbW9yeV9hZGFwdGVyXzEuU2Vzc2lvbkF3YXJlQWRhcHRlcjsgfSB9KTtcbnZhciBjbHVzdGVyX2FkYXB0ZXJfMSA9IHJlcXVpcmUoXCIuL2NsdXN0ZXItYWRhcHRlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNsdXN0ZXJBZGFwdGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbHVzdGVyX2FkYXB0ZXJfMS5DbHVzdGVyQWRhcHRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNsdXN0ZXJBZGFwdGVyV2l0aEhlYXJ0YmVhdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2x1c3Rlcl9hZGFwdGVyXzEuQ2x1c3RlckFkYXB0ZXJXaXRoSGVhcnRiZWF0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWVzc2FnZVR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsdXN0ZXJfYWRhcHRlcl8xLk1lc3NhZ2VUeXBlOyB9IH0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/socket.io-adapter@2.5.5/node_modules/socket.io-adapter/dist/index.js\n");

/***/ })

};
;